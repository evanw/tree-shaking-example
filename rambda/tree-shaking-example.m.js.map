{"version":3,"file":"tree-shaking-example.m.js","sources":["../src/rambda.js","../node_modules/rambda/dist/rambda.esm.js"],"sourcesContent":["import {range, compose, filter} from 'rambda'\n\nfunction isOdd(x){\n  return x % 2 === 0\n}\n\nfunction fn(x) {\n  return compose(\n    filter(isOdd),\n    range(2)\n  )(x)\n}\n\nconsole.log(fn(10))\n","function add(x, y) {\n  if (y === undefined) {\n    return yHolder => add(x, yHolder);\n  }\n\n  return x + y;\n}\n\nfunction addIndex(functor) {\n  return function (fn, ...rest) {\n    let cnt = 0;\n    const newFn = (...args) => fn.apply(null, [...args, cnt++]);\n\n    return functor.apply(null, [newFn, ...rest]);\n  };\n}\n\nfunction adjust(fn, index, arr) {\n  if (index === undefined) {\n    return (indexHolder, arrHolder) => adjust(fn, indexHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => adjust(fn, index, arrHolder);\n  }\n\n  const clone = arr.concat();\n\n  return clone.map((val, key) => {\n    if (key === index) {\n      return fn(arr[index]);\n    }\n\n    return val;\n  });\n}\n\nfunction filterObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    if (fn(obj[prop], prop)) {\n      willReturn[prop] = obj[prop];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction filter(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => filter(fn, arrHolder);\n  }\n\n  if (arr.length === undefined) {\n    return filterObject(fn, arr);\n  }\n  let index = -1;\n  let resIndex = 0;\n  const len = arr.length;\n  const willReturn = [];\n\n  while (++index < len) {\n    const value = arr[index];\n\n    if (fn(value)) {\n      willReturn[resIndex++] = value;\n    }\n  }\n\n  return willReturn;\n}\n\nfunction all(condition, arr) {\n  if (arr === undefined) {\n    return arrHolder => all(condition, arrHolder);\n  }\n\n  return filter(condition, arr).length === arr.length;\n}\n\nfunction any(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => any(fn, arrHolder);\n  }\n  let counter = 0;\n\n  while (counter < arr.length) {\n    if (fn(arr[counter])) {\n      return true;\n    }\n    counter++;\n  }\n\n  return false;\n}\n\nfunction allPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => allPass(conditions, xHolder);\n  }\n\n  return !any(condition => !condition(x), conditions);\n}\n\nfunction anyPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => anyPass(conditions, xHolder);\n  }\n\n  return any(condition => condition(x))(conditions);\n}\n\nfunction append(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => append(x, arrHolder);\n  }\n  if (typeof arr === 'string') {\n    return `${arr}${x}`;\n  }\n  const clone = arr.concat();\n\n  clone.push(x);\n\n  return clone;\n}\n\nfunction both(x, y) {\n  if (y === undefined) {\n    return yHolder => both(x, yHolder);\n  }\n\n  return input => x(input) && y(input);\n}\n\n//Taken from https://github.com/getify/Functional-Light-JS/blob/master/ch4.md\nfunction compose(...fns) {\n  return result => {\n    const list = fns.slice();\n\n    while (list.length > 0) {\n      result = list.pop()(result);\n    }\n\n    return result;\n  };\n}\n\nfunction concat(x, y) {\n  if (y === undefined) {\n    return yHolder => concat(x, yHolder);\n  }\n\n  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];\n}\n\nfunction type(a) {\n  const typeOf = typeof a;\n\n  if (a === null) {\n    return 'Null';\n  } else if (a === undefined) {\n    return 'Undefined';\n  } else if (typeOf === 'boolean') {\n    return 'Boolean';\n  } else if (typeOf === 'number') {\n    return 'Number';\n  } else if (typeOf === 'string') {\n    return 'String';\n  } else if (Array.isArray(a)) {\n    return 'Array';\n  } else if (a instanceof RegExp) {\n    return 'RegExp';\n  }\n\n  const asStr = a.toString();\n\n  if (asStr.startsWith('async')) {\n    return 'Async';\n  } else if (asStr === '[object Promise]') {\n    return 'Promise';\n  } else if (asStr.includes('function') || asStr.includes('=>')) {\n    return 'Function';\n  }\n\n  return 'Object';\n}\n\nfunction equals(a, b) {\n  if (arguments.length === 1) {\n    return bHolder => equals(a, bHolder);\n  }\n\n  if (a === b) {\n    return true;\n  }\n  const aType = type(a);\n\n  if (aType !== type(b)) {\n    return false;\n  }\n\n  if (aType === 'Array') {\n    const aClone = Array.from(a);\n    const bClone = Array.from(b);\n\n    if (aClone.toString() !== bClone.toString()) {\n\n      return false;\n    }\n    let loopArrayFlag = true;\n\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag) {\n\n        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {\n          loopArrayFlag = false;\n        }\n      }\n    });\n\n    return loopArrayFlag;\n  }\n\n  if (aType === 'Object') {\n    const aKeys = Object.keys(a);\n\n    if (aKeys.length !== Object.keys(b).length) {\n\n      return false;\n    }\n\n    let loopObjectFlag = true;\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag) {\n        const aValue = a[aKeyInstance];\n        const bValue = b[aKeyInstance];\n\n        if (aValue !== bValue && !equals(aValue, bValue)) {\n          loopObjectFlag = false;\n        }\n      }\n    });\n\n    return loopObjectFlag;\n  }\n\n  return false;\n}\n\nfunction contains(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => contains(x, arrHolder);\n  }\n  let index = -1;\n  let flag = false;\n\n  while (++index < arr.length && !flag) {\n    if (equals(arr[index], x)) {\n      flag = true;\n    }\n  }\n\n  return flag;\n}\n\n//taken from the last comment of https://gist.github.com/mkuklis/5294248\n\nfunction curry(f, a = []) {\n  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);\n}\n\nvar dec = (x => x - 1);\n\nfunction defaultTo(defaultArgument, inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);\n  }\n\n  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true ? defaultArgument : inputArgument;\n}\n\nfunction divide(x, y) {\n  if (y === undefined) {\n    return yHolder => divide(x, yHolder);\n  }\n\n  return x / y;\n}\n\nfunction drop(dropNumber, x) {\n  if (x === undefined) {\n    return xHolder => drop(dropNumber, xHolder);\n  }\n\n  return x.slice(dropNumber);\n}\n\nfunction dropLast(dropNumber, x) {\n  if (x === undefined) {\n    return xHolder => dropLast(dropNumber, xHolder);\n  }\n\n  return x.slice(0, -dropNumber);\n}\n\nfunction either(x, y) {\n  if (y === undefined) {\n    return yHolder => either(x, yHolder);\n  }\n\n  return input => x(input) || y(input);\n}\n\nfunction endsWith(x, y) {\n  if (y === undefined) {\n    return yHolder => endsWith(x, yHolder);\n  }\n\n  return y.endsWith(x);\n}\n\nvar inc = (x => x + 1);\n\nfunction find(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => find(fn, arrHolder);\n  }\n\n  return arr.find(fn);\n}\n\nfunction findIndex(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => findIndex(fn, arrHolder);\n  }\n  const len = arr.length;\n  let index = -1;\n\n  while (++index < len) {\n    if (fn(arr[index])) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction flatten(arr, willReturn) {\n  willReturn = willReturn === undefined ? [] : willReturn;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      flatten(arr[i], willReturn);\n    } else {\n      willReturn.push(arr[i]);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction flipExport(fn) {\n  return (...input) => {\n    if (input.length === 1) {\n      return holder => fn(holder, input[0]);\n    } else if (input.length === 2) {\n      return fn(input[1], input[0]);\n    }\n\n    return undefined;\n  };\n}\n\nfunction flip(fn, ...input) {\n  return flipExport(fn);\n}\n\nfunction tap(fn, x) {\n  if (x === undefined) {\n    return xHolder => tap(fn, xHolder);\n  }\n\n  fn(x);\n\n  return x;\n}\n\nfunction mapObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    willReturn[prop] = fn(obj[prop], prop);\n  }\n\n  return willReturn;\n}\n\nfunction map(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => map(fn, arrHolder);\n  }\n  if (arr.length === undefined) {\n    return mapObject(fn, arr);\n  }\n  let index = -1;\n  const len = arr.length;\n  const willReturn = Array(len);\n\n  while (++index < len) {\n    willReturn[index] = fn(arr[index]);\n  }\n\n  return willReturn;\n}\n\nfunction forEach(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => forEach(fn, arrHolder);\n  }\n\n  return map(tap(fn), arr);\n}\n\nfunction has(prop, obj) {\n  if (obj === undefined) {\n    return objHolder => has(prop, objHolder);\n  }\n\n  return obj[prop] !== undefined;\n}\n\nfunction head(a) {\n  if (typeof a === 'string') {\n    return a[0] || '';\n  }\n\n  return a[0];\n}\n\nfunction ifElse(condition, ifFn, elseFn) {\n  if (ifFn === undefined) {\n    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);\n  } else if (elseFn === undefined) {\n    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);\n  }\n\n  return input => {\n    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (conditionResult === true) {\n      return ifFn(input);\n    }\n\n    return elseFn(input);\n  };\n}\n\nfunction is(xPrototype, x) {\n  if (x === undefined) {\n    return xHolder => is(xPrototype, xHolder);\n  }\n\n  return x instanceof xPrototype || x.constructor === xPrototype;\n}\n\nfunction isNil(x) {\n  return x === undefined || x === null;\n}\n\nfunction includes(x, y) {\n  if (y === undefined) {\n    return yHolder => includes(x, yHolder);\n  }\n\n  return y.includes(x);\n}\n\nfunction indexOf(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => indexOf(x, arrHolder);\n  }\n  let index = -1;\n  const length = arr.length;\n\n  while (++index < length) {\n    if (arr[index] === x) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction baseSlice(array, start, end) {\n  let index = -1;\n  let length = array.length;\n\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n\n  const result = Array(length);\n\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n\n  return result;\n}\n\nfunction init(a) {\n  if (typeof a === 'string') {\n    return a.slice(0, -1);\n  }\n\n  return a.length ? baseSlice(a, 0, -1) : [];\n}\n\nfunction join(glue, arr) {\n  if (arr === undefined) {\n    return arrHolder => join(glue, arrHolder);\n  }\n\n  return arr.join(glue);\n}\n\nfunction lastIndexOf(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => lastIndexOf(x, arrHolder);\n  }\n  let willReturn = -1;\n\n  arr.map((value, key) => {\n    if (equals(value, x)) {\n      willReturn = key;\n    }\n  });\n\n  return willReturn;\n}\n\nfunction last(a) {\n  if (typeof a === 'string') {\n    return a[a.length - 1] || '';\n  }\n\n  return a[a.length - 1];\n}\n\nfunction length(x) {\n  return x.length;\n}\n\nfunction match(regex, x) {\n  if (x === undefined) {\n    return xHolder => match(regex, xHolder);\n  }\n  const willReturn = x.match(regex);\n\n  return willReturn === null ? [] : willReturn;\n}\n\nfunction merge(obj, newProps) {\n  if (newProps === undefined) {\n    return newPropsHolder => merge(obj, newPropsHolder);\n  }\n\n  return Object.assign({}, obj, newProps);\n}\n\nfunction modulo(x, y) {\n  if (y === undefined) {\n    return yHolder => modulo(x, yHolder);\n  }\n\n  return x % y;\n}\n\nfunction multiply(x, y) {\n  if (y === undefined) {\n    return yHolder => multiply(x, yHolder);\n  }\n\n  return x * y;\n}\n\nfunction none(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => none(fn, arr);\n  }\n\n  return arr.filter(fn).length === 0;\n}\n\nfunction omit(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => omit(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n\n  const keysValue = typeof keys === 'string' ? keys = keys.split(',') : keys;\n\n  const willReturn = {};\n\n  for (const key in obj) {\n    if (!keysValue.includes(key)) {\n      willReturn[key] = obj[key];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction partialCurry(fn, inputArguments = {}) {\n  return inputArgumentsHolder => {\n    if (type(fn) === 'Async' || type(fn) === 'Promise') {\n      return new Promise((resolve, reject) => {\n        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);\n      });\n    }\n\n    return fn(merge(inputArgumentsHolder, inputArguments));\n  };\n}\n\nfunction path(pathArr, obj) {\n  if (arguments.length === 1) {\n    return objHolder => path(pathArr, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  let willReturn = obj;\n  let counter = 0;\n\n  const pathArrValue = typeof pathArr === 'string' ? pathArr = pathArr.split('.') : pathArr;\n\n  while (counter < pathArrValue.length) {\n    if (willReturn === null || willReturn === undefined) {\n      return undefined;\n    }\n    willReturn = willReturn[pathArrValue[counter]];\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pathOr(defaultValue, inputPath, inputObject) {\n  return defaultTo(defaultValue, path(inputPath, inputObject));\n}\n\nvar pathOr$1 = curry(pathOr);\n\nfunction pick(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pick(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pickAll(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pickAll(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    } else {\n      willReturn[keysValue[counter]] = undefined;\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pipe(...fns) {\n  return compose(...fns.reverse());\n}\n\nfunction pluck(keyToPluck, arr) {\n  if (arr === undefined) {\n    return arrHolder => pluck(keyToPluck, arrHolder);\n  }\n  const willReturn = [];\n\n  map(val => {\n    if (!(val[keyToPluck] === undefined)) {\n      willReturn.push(val[keyToPluck]);\n    }\n  }, arr);\n\n  return willReturn;\n}\n\nfunction prepend(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => prepend(x, arrHolder);\n  }\n  if (typeof arr === 'string') {\n    return `${x}${arr}`;\n  }\n  const clone = arr.concat();\n\n  clone.unshift(x);\n\n  return clone;\n}\n\nfunction prop(key, obj) {\n  if (obj === undefined) {\n    return objHolder => prop(key, objHolder);\n  }\n\n  return obj[key];\n}\n\nfunction propEq(key, x, obj) {\n  if (x === undefined) {\n    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);\n  } else if (obj === undefined) {\n    return objHolder => propEq(key, x, objHolder);\n  }\n\n  return obj[key] === x;\n}\n\nfunction range(start, end) {\n  if (end === undefined) {\n    return endHolder => range(start, endHolder);\n  }\n  const willReturn = [];\n\n  for (let i = start; i < end; i++) {\n    willReturn.push(i);\n  }\n\n  return willReturn;\n}\n\nfunction reduce(fn, initialValue, arr) {\n  if (initialValue === undefined) {\n    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => reduce(fn, initialValue, arrHolder);\n  }\n\n  return arr.reduce(fn, initialValue);\n}\n\nfunction reject(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => reject(fn, arrHolder);\n  }\n\n  return filter(x => !fn(x), arr);\n}\n\nfunction repeat(x, num) {\n  if (num === undefined) {\n    return numHolder => repeat(x, numHolder);\n  }\n  const willReturn = Array(num);\n\n  return willReturn.fill(x);\n}\n\nfunction replace(regex, replacer, str) {\n  if (replacer === undefined) {\n    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);\n  } else if (str === undefined) {\n    return strHolder => replace(regex, replacer, strHolder);\n  }\n\n  return str.replace(regex, replacer);\n}\n\nfunction reverse(arr) {\n  const clone = arr.concat();\n\n  return clone.reverse();\n}\n\nfunction sort(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => sort(fn, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.sort(fn);\n}\n\nfunction sortBy(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => sortBy(fn, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.sort((a, b) => {\n    const fnA = fn(a);\n    const fnB = fn(b);\n\n    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;\n  });\n}\n\nfunction split(glue, str) {\n  if (str === undefined) {\n    return strHolder => split(glue, strHolder);\n  }\n\n  return str.split(glue);\n}\n\nfunction splitEvery(num, x) {\n  if (x === undefined) {\n    return xHolder => splitEvery(num, xHolder);\n  }\n\n  const numValue = num > 1 ? num : 1;\n\n  const willReturn = [];\n  let counter = 0;\n\n  while (counter < x.length) {\n    willReturn.push(x.slice(counter, counter += numValue));\n  }\n\n  return willReturn;\n}\n\nfunction startsWith(x, y) {\n  if (y === undefined) {\n    return yHolder => startsWith(x, yHolder);\n  }\n\n  return y.startsWith(x);\n}\n\nfunction subtract(x, y) {\n  if (y === undefined) {\n    return yHolder => subtract(x, yHolder);\n  }\n\n  return x - y;\n}\n\nfunction tail(arr) {\n  return drop(1, arr);\n}\n\nfunction take(num, x) {\n  if (x === undefined) {\n    return xHolder => take(num, xHolder);\n  }\n  if (typeof x === 'string') {\n    return x.slice(0, num);\n  }\n\n  return baseSlice(x, 0, num);\n}\n\nfunction takeLast(num, x) {\n  if (x === undefined) {\n    return xHolder => takeLast(num, xHolder);\n  }\n  const len = x.length;\n\n  let numValue = num > len ? len : num;\n\n  if (typeof x === 'string') {\n    return x.slice(len - numValue);\n  }\n  numValue = len - numValue;\n\n  return baseSlice(x, numValue, len);\n}\n\nfunction test(regex, str) {\n  if (str === undefined) {\n    return strHolder => test(regex, strHolder);\n  }\n\n  return str.search(regex) !== -1;\n}\n\nfunction times(fn, num) {\n  if (num === undefined) {\n    return numHolder => times(fn, numHolder);\n  }\n\n  return map(fn, range(0, num));\n}\n\nfunction toLower(x) {\n  return x.toLowerCase();\n}\n\nfunction toUpper(x) {\n  return x.toUpperCase();\n}\n\nfunction toString(x) {\n  return x.toString();\n}\n\nfunction uniq(arr) {\n  let index = -1;\n  const willReturn = [];\n\n  while (++index < arr.length) {\n    const value = arr[index];\n\n    if (!contains(value, willReturn)) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction uniqWith(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => uniqWith(fn, arrHolder);\n  }\n\n  let index = -1;\n  const willReturn = [];\n\n  while (++index < arr.length) {\n    const value = arr[index];\n    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);\n\n    if (!flag) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction update(index, newValue, arr) {\n  if (newValue === undefined) {\n    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => update(index, newValue, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.fill(newValue, index, index + 1);\n}\n\nfunction values(obj) {\n  const willReturn = [];\n\n  for (const key in obj) {\n    willReturn.push(obj[key]);\n  }\n\n  return willReturn;\n}\n\nfunction without(itemsToOmit, collection) {\n  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);\n}\n\nconst always = x => () => x;\nconst complement = fn => input => !fn(input);\nconst F = () => false;\nconst identity = x => x;\nconst not = x => !x;\nconst T = () => true;\nconst trim = x => x.trim();\n\nexport { always, complement, F, identity, not, T, trim, add, addIndex, adjust, all, allPass, anyPass, any, append, both, compose, concat, contains, curry, dec, defaultTo, divide, drop, dropLast, either, endsWith, inc, equals, filter, find, findIndex, flatten, flip, forEach, has, head, ifElse, is, isNil, includes, indexOf, init, join, lastIndexOf, last, length, map, match, merge, modulo, multiply, none, omit, partialCurry, path, pathOr$1 as pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, range, reduce, reject, repeat, replace, reverse, sort, sortBy, split, splitEvery, startsWith, subtract, tap, tail, take, takeLast, test, times, toLower, toUpper, toString, type, uniq, uniqWith, update, values, without };\n//# sourceMappingURL=rambda.esm.js.map\n"],"names":["isOdd","x","console","log","fns","result","list","slice","length","pop","compose","filter","fn","arr","undefined","arrHolder","obj","willReturn","prop","filterObject","index","resIndex","len","value","range","start","end","endHolder","i","push"],"mappings":"AAEA,SAASA,EAAMC,GACb,OAAOA,EAAI,GAAM,EAGnB,IAAYA,EAOZC,QAAQC,KAPIF,EAOG,GC0Df,YA+DoBG,GAClB,OAAOC,IACL,MAAMC,EAAOF,EAAIG,QAEjB,KAAOD,EAAKE,OAAS,GACnBH,EAASC,EAAKG,KAALH,CAAWD,GAGtB,OAAOA,GDvIFK,CCwCT,SAASC,EAAOC,EAAIC,GAClB,QAAYC,IAARD,EACF,OAAOE,GAAaJ,EAAOC,EAAIG,GAGjC,QAAmBD,IAAfD,EAAIL,OACN,OAlBJ,SAAsBI,EAAII,GACxB,MAAMC,KAEN,IAAK,MAAMC,KAAQF,EACbJ,EAAGI,EAAIE,GAAOA,KAChBD,EAAWC,GAAQF,EAAIE,IAI3B,OAAOD,EASEE,CAAaP,EAAIC,GAE1B,IAAIO,GAAS,EACTC,EAAW,EACf,MAAMC,EAAMT,EAAIL,OACVS,KAEN,OAASG,EAAQE,GAAK,CACpB,MAAMC,EAAQV,EAAIO,GAEdR,EAAGW,KACLN,EAAWI,KAAcE,GAI7B,OAAON,ED5DLN,CAAOX,GC0IX,SAimBSwB,EAAMC,EAAOC,GACpB,QAAYZ,IAARY,EACF,OAAOC,GAAaH,EAAMC,EAAOE,GAEnC,MAAMV,KAEN,IAAK,IAAIW,EAAIH,EAAOG,EAAIF,EAAKE,IAC3BX,EAAWY,KAAKD,GAGlB,OAAOX,EDpvBLO,CAAM,GAFDd,CAGLT"}