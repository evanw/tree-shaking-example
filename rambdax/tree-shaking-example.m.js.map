{"version":3,"file":"tree-shaking-example.m.js","sources":["../node_modules/rambdax/dist/rambdax.esm.js","../node_modules/rambda/dist/rambda.esm.js","../src/rambdax.js"],"sourcesContent":["import { F, T, add, addIndex, adjust, all, allPass, always, any, anyPass, append, both, complement, compose, concat, contains, curry, dec, defaultTo, divide, drop, dropLast, either, endsWith, equals, filter, find, findIndex, flatten, flip, forEach, has, head, identity, ifElse, inc, includes, indexOf, init, is, isNil, join, last, lastIndexOf, length, map, match, merge, modulo, multiply, none, not, omit, partialCurry, path, pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, range, reduce, reject, repeat, replace, reverse, sort, sortBy, split, splitEvery, startsWith, subtract, tail, take, takeLast, tap, test, times, toLower, toString, toUpper, trim, type, uniq, uniqWith, update, values, without } from 'rambda';\n\nfunction assocPath(path$$1, x, obj) {\n  const pathValue = typeof path$$1 === 'string' ? path$$1.split('.') : path$$1;\n\n  const lastProp = pathValue[pathValue.length - 1];\n\n  let newProps = { [lastProp]: x };\n\n  let counter = pathValue.length - 2;\n\n  while (counter > -1) {\n    const prop$$1 = pathValue[counter];\n    newProps = { [prop$$1]: newProps };\n\n    counter--;\n  }\n\n  return Object.assign({}, obj, newProps);\n}\n\nvar assocPath$1 = curry(assocPath);\n\nconst types = ['Null', 'Undefined', 'RegExp'];\n\nfunction compact(arr) {\n  return filter(a => {\n    const currentType = type(a);\n    if (types.includes(currentType)) {\n      return false;\n    }\n    if (currentType === 'Object') {\n      return !equals(a, {});\n    }\n\n    return a.length !== 0;\n  }, arr);\n}\n\nfunction composeAsync(...inputArguments) {\n  try {\n    return async function (startArgument) {\n      let argumentsToPass = startArgument;\n\n      while (inputArguments.length !== 0) {\n        const fn = inputArguments.pop();\n        if (type(fn) === 'Async' || type(fn) === 'Promise') {\n          argumentsToPass = await fn(argumentsToPass);\n        } else {\n          argumentsToPass = fn(argumentsToPass);\n        }\n      }\n\n      return argumentsToPass;\n    };\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction debounce(func, ms, immediate = false) {\n  let timeout;\n\n  return function (...input) {\n    const later = function () {\n      timeout = null;\n      if (!immediate) {\n        func.apply(null, input);\n      }\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, ms);\n    if (callNow) {\n      func.apply(null, input);\n    }\n  };\n}\n\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('RAMBDAX_DELAY');\n    }, ms);\n  });\n}\n\nfunction debug(...input) {\n  console.log(...input);\n  process.exit();\n}\n\nfunction evolve(rules, input) {\n  const clone = Object.assign({}, input);\n  const propRules = filter(x => clone[x] !== undefined)(Object.keys(rules));\n\n  if (propRules.length === 0) {\n    return input;\n  }\n\n  propRules.map(prop$$1 => {\n    const fn = rules[prop$$1];\n    if (type(fn) === 'Function') {\n      clone[prop$$1] = fn(clone[prop$$1]);\n    } else if (type(fn) === 'Object') {\n      clone[prop$$1] = evolve(fn, clone[prop$$1]);\n    }\n  });\n\n  return clone;\n}\n\nvar evolve$1 = curry(evolve);\n\nfunction greater(x, y) {\n  if (y === undefined) {\n    return yHolder => greater(x, yHolder);\n  }\n\n  return y > x;\n}\n\nfunction createThenable(x) {\n  return async function (input) {\n    return x(input);\n  };\n}\n\nfunction ifElseAsync(condition, ifFn, elseFn) {\n  if (ifFn === undefined) {\n    return (ifFnHolder, elseFnHolder) => ifElseAsync(condition, ifFnHolder, elseFnHolder);\n  } else if (elseFn === undefined) {\n    return elseFnHolder => ifElseAsync(condition, ifFn, elseFnHolder);\n  }\n\n  return input => new Promise((resolve, reject$$1) => {\n    const conditionPromise = createThenable(condition);\n    const ifFnPromise = createThenable(ifFn);\n    const elseFnPromise = createThenable(elseFn);\n\n    conditionPromise(input).then(conditionResult => {\n      const promised = conditionResult === true ? ifFnPromise : elseFnPromise;\n\n      promised(input).then(resolve).catch(reject$$1);\n    }).catch(reject$$1);\n  });\n}\n\nfunction intersection(a, b) {\n  if (b === undefined) {\n    return bHolder => intersection(a, bHolder);\n  }\n\n  return filter(val => b.includes(val))(a);\n}\n\nfunction isPromiseLike(x) {\n  return ['Async', 'Promise'].includes(type(x));\n}\n\nfunction isValid({ input, schema }) {\n  if (type(input) === 'Object' && type(schema) === 'Object') {\n    let flag = true;\n    for (const requirement in schema) {\n      if (flag) {\n        const rule = schema[requirement];\n        const ruleType = type(rule);\n        const inputProp = input[requirement];\n        const inputPropType = type(input[requirement]);\n\n        if (ruleType === 'Object' && rule.type === 'ArrayOfSchemas' && inputPropType === 'Array') {\n          inputProp.map(val => {\n            let localFlag = false;\n            rule.rule.map(singleRule => {\n              if (isValid(val, singleRule)) {\n                localFlag = true;\n              }\n            });\n            if (localFlag === false) {\n              flag = false;\n            }\n          });\n        } else if (ruleType === 'String') {\n          if (inputProp !== undefined) {\n            if (toLower(inputPropType) !== rule) {\n              flag = false;\n            }\n          } else {\n            flag = false;\n          }\n        } else if (typeof rule === 'function') {\n          if (rule(inputProp) === false) {\n            flag = false;\n          }\n        } else if (ruleType === 'Object' && inputPropType === 'Object') {\n          if (!isValid(inputProp, rule)) {\n            flag = false;\n          }\n        } else if (ruleType === 'Array' && inputPropType === 'String') {\n          if (!contains(inputProp, rule)) {\n            flag = false;\n          }\n        } else if (ruleType === 'Array' && inputPropType === 'Array' && rule.length === 1 && inputProp.length > 0) {\n          const arrayRuleType = type(rule[0]);\n\n          if (arrayRuleType === 'String') {\n            const result = any(val => toLower(type(val)) !== rule[0], inputProp);\n\n            if (result) {\n              flag = false;\n            }\n          } else if (arrayRuleType === 'Object') {\n            const result = any(val => !isValid(val, rule[0]))(inputProp);\n            if (result) {\n              flag = false;\n            }\n          }\n        } else if (ruleType === 'RegExp' && inputPropType === 'String') {\n          if (!test(rule, inputProp)) {\n            flag = false;\n          }\n        } else {\n          flag = false;\n        }\n      }\n    }\n\n    return flag;\n  }\n\n  return false;\n}\n\nfunction less(x, y) {\n  if (y === undefined) {\n    return yHolder => less(x, yHolder);\n  }\n\n  return y < x;\n}\n\nasync function mapAsyncFn(fn, arr) {\n  try {\n    const willReturn = [];\n    for (const a of arr) {\n      willReturn.push((await fn(a)));\n    }\n\n    return willReturn;\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction mapAsync(fn, arr) {\n  if (arr === undefined) {\n    return async holder => await mapAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    mapAsyncFn(fn, arr).then(resolve).catch(reject$$1);\n  });\n}\n\nasync function mapFastAsyncFn(fn, arr) {\n  try {\n    const promised = arr.map(a => fn(a));\n\n    return await Promise.all(promised);\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction mapFastAsync(fn, arr) {\n  if (arr === undefined) {\n    return async holder => await mapFastAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    mapFastAsyncFn(fn, arr).then(resolve).catch(reject$$1);\n  });\n}\n\nconst cache = {};\n\nconst normalizeObject = obj => {\n  const sortFn = (a, b) => a > b;\n  const willReturn = {};\n  compose(map(prop$$1 => willReturn[prop$$1] = obj[prop$$1]), sort(sortFn))(Object.keys(obj));\n\n  return willReturn;\n};\n\nconst stringify = a => {\n  if (type(a) === 'String') {\n    return a;\n  } else if (['Function', 'Async'].includes(type(a))) {\n    const compacted = replace(/\\s{1,}/g, ' ', a.toString());\n\n    return replace(/\\s/g, '_', take(15, compacted));\n  } else if (type(a) === 'Object') {\n    a = normalizeObject(a);\n  }\n\n  return JSON.stringify(a);\n};\n\nconst generateProp = (fn, ...inputArguments) => {\n  let propString = '';\n  inputArguments.map(inputArgument => {\n    propString += `${stringify(inputArgument)}_`;\n  });\n\n  return `${propString}${stringify(fn)}`;\n};\n\nfunction memoize(fn, ...inputArguments) {\n  if (arguments.length === 1) {\n    return (...inputArgumentsHolder) => memoize(fn, ...inputArgumentsHolder);\n  }\n  const prop$$1 = generateProp(fn, ...inputArguments);\n  if (prop$$1 in cache) {\n    return cache[prop$$1];\n  }\n  if (type(fn) === 'Async') {\n    return new Promise(resolve => {\n      fn(...inputArguments).then(result => {\n        cache[prop$$1] = result;\n        resolve(result);\n      });\n    });\n  }\n  const result = fn(...inputArguments);\n  cache[prop$$1] = result;\n\n  return result;\n}\n\nfunction mergeAll(arr) {\n  let willReturn = {};\n  map(val => {\n    willReturn = merge(willReturn, val);\n  }, arr);\n\n  return willReturn;\n}\n\nfunction omitBy(fn, obj) {\n  if (arguments.length === 1) {\n    return holder => omitBy(fn, holder);\n  }\n\n  const willReturn = {};\n  for (const prop$$1 in obj) {\n    if (!fn(prop$$1, obj[prop$$1])) {\n      willReturn[prop$$1] = obj[prop$$1];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction onceFn(fn, context) {\n  let result;\n\n  return function () {\n    if (fn) {\n      result = fn.apply(context || this, arguments);\n      fn = null;\n    }\n\n    return result;\n  };\n}\n\nfunction once(fn, context) {\n  if (arguments.length === 1) {\n    const wrap = onceFn(fn, context);\n\n    return curry(wrap);\n  }\n\n  return onceFn(fn, context);\n}\n\nfunction pickBy(fn, obj) {\n  if (arguments.length === 1) {\n    return holder => pickBy(fn, holder);\n  }\n\n  const willReturn = {};\n  for (const prop$$1 in obj) {\n    if (fn(prop$$1, obj[prop$$1])) {\n      willReturn[prop$$1] = obj[prop$$1];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction helper({ condition, inputArgument, prop: prop$$1 }) {\n  return new Promise((resolve, reject$$1) => {\n    if (!(type(condition) === 'Async')) {\n      return resolve({\n        type: prop$$1,\n        payload: condition(inputArgument)\n      });\n    }\n\n    condition(inputArgument).then(result => {\n      resolve({\n        type: prop$$1,\n        payload: result\n      });\n    }).catch(err => reject$$1(err));\n  });\n}\n\nfunction produce(conditions, inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => produce(conditions, inputArgumentHolder);\n  }\n  let asyncConditionsFlag = false;\n  for (const prop$$1 in conditions) {\n    if (asyncConditionsFlag === false && type(conditions[prop$$1]) === 'Async') {\n      asyncConditionsFlag = true;\n    }\n  }\n\n  if (asyncConditionsFlag === false) {\n    const willReturn = {};\n    for (const prop$$1 in conditions) {\n      willReturn[prop$$1] = conditions[prop$$1](inputArgument);\n    }\n\n    return willReturn;\n  }\n  const promised = [];\n  for (const prop$$1 in conditions) {\n    const condition = conditions[prop$$1];\n    promised.push(helper({\n      inputArgument,\n      condition,\n      prop: prop$$1\n    }));\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    Promise.all(promised).then(results => {\n      const willReturn = {};\n\n      map(result => willReturn[result.type] = result.payload, results);\n\n      resolve(willReturn);\n    }).catch(err => reject$$1(err));\n  });\n}\n\nfunction random(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction rangeBy(startNum, endNum, distance) {\n  if (endNum === undefined) {\n    return (endNumHolder, distanceHolder) => rangeBy(startNum, endNumHolder, distanceHolder);\n  } else if (distance === undefined) {\n    return distanceHolder => rangeBy(startNum, endNum, distanceHolder);\n  }\n\n  const isInteger = !distance.toString().includes('.');\n  if (startNum > endNum) {\n    const startNumHolder = startNum;\n    startNum = endNum;\n    endNum = startNumHolder;\n  }\n  const willReturn = [startNum];\n  let valueToPush = startNum;\n\n  if (isInteger) {\n    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));\n    for (const i of loopIndexes) {\n      valueToPush += distance;\n      willReturn.push(valueToPush);\n    }\n  } else {\n    const decimalLength = compose(length, last, split('.'))(distance.toString());\n    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));\n    for (const i of loopIndexes) {\n      valueToPush += distance;\n      willReturn.push(Number(valueToPush.toFixed(decimalLength)));\n    }\n  }\n\n  return willReturn;\n}\n\nfunction renameProps(conditions, inputObject) {\n  if (inputObject === undefined) {\n    return inputObjectHolder => renameProps(conditions, inputObjectHolder);\n  }\n  const renamed = {};\n  Object.keys(conditions).map(renameConditionProp => {\n    if (Object.keys(inputObject).includes(renameConditionProp)) {\n      renamed[conditions[renameConditionProp]] = inputObject[renameConditionProp];\n    }\n  });\n\n  return merge(renamed, omit(Object.keys(conditions), inputObject));\n}\n\nfunction resolveMethod(promises) {\n  return new Promise((res, rej) => {\n    let counter = 0;\n    const props = {};\n    const promisedArr = [];\n    for (const prop$$1 in promises) {\n      props[counter] = prop$$1;\n      promisedArr.push(promises[prop$$1]);\n      counter++;\n    }\n    Promise.all(promisedArr).then(result => {\n      const willReturn = {};\n      result.map((val, key) => {\n        const prop$$1 = props[key];\n        willReturn[prop$$1] = val;\n      });\n\n      res(willReturn);\n    }).catch(rej);\n  });\n}\n\nconst resolveSecureWrapper = promise => new Promise(res => {\n  promise.then(result => {\n    res({\n      payload: result,\n      type: 'RESULT'\n    });\n  }).catch(err => {\n    res({\n      payload: err,\n      type: 'ERROR'\n    });\n  });\n});\n\nasync function resolveSecure(input) {\n  try {\n    const promised = map(a => resolveSecureWrapper(a), input);\n\n    return await Promise.all(promised);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nfunction shuffle(arrayRaw) {\n  const array = arrayRaw.concat();\n  let counter = array.length;\n  while (counter > 0) {\n    const index = Math.floor(Math.random() * counter);\n    counter--;\n    const temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n\n  return array;\n}\n\nconst NO_MATCH_FOUND = Symbol('NO_MATCH_FOUND');\n\nconst getMatchingKeyValuePair = (cases, testValue, defaultValue) => {\n  let iterationValue;\n\n  for (let index = 0; index < cases.length; index++) {\n    iterationValue = cases[index].test(testValue);\n\n    if (iterationValue !== NO_MATCH_FOUND) {\n      return {\n        key: cases[index].key,\n        value: iterationValue\n      };\n    }\n  }\n\n  return {\n    key: 'default',\n    value: defaultValue\n  };\n};\n\nconst isEqual = (testValue, matchValue) => {\n  const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);\n\n  return willReturn;\n};\n\nconst is$2 = (testValue, matchResult = true) => ({\n  key: testValue,\n  test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND\n});\n\nclass Switchem {\n\n  constructor(defaultValue, cases, willMatch) {\n    if (defaultValue !== undefined && cases === undefined && willMatch === undefined) {\n      this.cases = [];\n      this.defaultValue = undefined;\n      this.willMatch = defaultValue;\n    } else {\n      this.cases = cases;\n      this.defaultValue = defaultValue;\n      this.willMatch = willMatch;\n    }\n\n    return this;\n  }\n\n  default(defaultValue) {\n    const holder = new Switchem(defaultValue, this.cases, this.willMatch);\n\n    return holder.match(this.willMatch);\n  }\n\n  is(testValue, matchResult) {\n    return new Switchem(this.defaultValue, [...this.cases, is$2(testValue, matchResult)], this.willMatch);\n  }\n\n  match(matchValue) {\n    const { key, value } = getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);\n\n    return typeof value === 'function' ? value(key, matchValue) : value;\n  }\n\n}\n\nfunction switcher(input) {\n  return new Switchem(input);\n}\n\nfunction tapAsync(fn, input) {\n  if (arguments.length === 1) {\n    return inputHolder => tapAsync(fn, inputHolder);\n  }\n  if (isPromiseLike(fn) === true) {\n    return new Promise((resolve, reject$$1) => {\n      fn(input).then(() => {\n        resolve(input);\n      }).catch(reject$$1);\n    });\n  }\n  fn(input);\n\n  return input;\n}\n\nfunction throttle(fn, ms) {\n  let wait = false;\n\n  return function (...input) {\n    if (!wait) {\n      fn.apply(null, input);\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n      }, ms);\n    }\n  };\n}\n\nfunction tryCatch(fn, input) {\n  const fnType = type(fn);\n  if (fnType === 'Async' || fnType === 'Promise') {\n    return new Promise(resolve => {\n      fn(input).then(resolve).catch(resolve);\n    });\n  }\n\n  try {\n    return fn(input);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction when(condition, whenTrueFn) {\n  if (whenTrueFn === undefined) {\n    return whenTrueFnHolder => when(condition, whenTrueFnHolder);\n  }\n\n  return input => {\n    const flag = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (flag) {\n      return whenTrueFn(input);\n    }\n\n    return input;\n  };\n}\n\nfunction where(conditions, obj) {\n  if (obj === undefined) {\n    return objHolder => where(conditions, objHolder);\n  }\n  let flag = true;\n  for (const prop$$1 in conditions) {\n    const result = conditions[prop$$1](obj[prop$$1]);\n    if (flag && result === false) {\n      flag = false;\n    }\n  }\n\n  return flag;\n}\n\nconst DELAY = 'RAMBDAX_DELAY';\n// Follows code generated by `run rambda`\nconst always$1 = always;\nconst complement$1 = complement;\nconst F$1 = F;\nconst identity$1 = identity;\nconst not$1 = not;\nconst T$1 = T;\nconst trim$1 = trim;\nconst add$1 = add;\nconst addIndex$1 = addIndex;\nconst adjust$1 = adjust;\nconst all$1 = all;\nconst allPass$1 = allPass;\nconst anyPass$1 = anyPass;\nconst any$1 = any;\nconst append$1 = append;\nconst both$1 = both;\nconst compose$1 = compose;\nconst concat$1 = concat;\nconst contains$1 = contains;\nconst curry$1 = curry;\nconst dec$1 = dec;\nconst defaultTo$1 = defaultTo;\nconst divide$1 = divide;\nconst drop$1 = drop;\nconst dropLast$1 = dropLast;\nconst either$1 = either;\nconst endsWith$1 = endsWith;\nconst inc$1 = inc;\nconst equals$1 = equals;\nconst filter$1 = filter;\nconst find$1 = find;\nconst findIndex$1 = findIndex;\nconst flatten$1 = flatten;\nconst flip$1 = flip;\nconst forEach$1 = forEach;\nconst has$1 = has;\nconst head$1 = head;\nconst ifElse$1 = ifElse;\nconst is$1 = is;\nconst isNil$1 = isNil;\nconst includes$1 = includes;\nconst indexOf$1 = indexOf;\nconst init$1 = init;\nconst join$1 = join;\nconst lastIndexOf$1 = lastIndexOf;\nconst last$1 = last;\nconst length$1 = length;\nconst map$1 = map;\nconst match$1 = match;\nconst merge$1 = merge;\nconst modulo$1 = modulo;\nconst multiply$1 = multiply;\nconst none$1 = none;\nconst omit$1 = omit;\nconst partialCurry$1 = partialCurry;\nconst path$1 = path;\nconst pathOr$1 = pathOr;\nconst pick$1 = pick;\nconst pickAll$1 = pickAll;\nconst pipe$1 = pipe;\nconst pluck$1 = pluck;\nconst prepend$1 = prepend;\nconst prop$1 = prop;\nconst propEq$1 = propEq;\nconst range$1 = range;\nconst reduce$1 = reduce;\nconst reject$1 = reject;\nconst repeat$1 = repeat;\nconst replace$1 = replace;\nconst reverse$1 = reverse;\nconst sort$1 = sort;\nconst sortBy$1 = sortBy;\nconst split$1 = split;\nconst splitEvery$1 = splitEvery;\nconst startsWith$1 = startsWith;\nconst subtract$1 = subtract;\nconst tap$1 = tap;\nconst tail$1 = tail;\nconst take$1 = take;\nconst takeLast$1 = takeLast;\nconst test$1 = test;\nconst times$1 = times;\nconst toLower$1 = toLower;\nconst toUpper$1 = toUpper;\nconst toString$1 = toString;\nconst type$1 = type;\nconst uniq$1 = uniq;\nconst uniqWith$1 = uniqWith;\nconst update$1 = update;\nconst values$1 = values;\nconst without$1 = without;\n\nexport { DELAY, always$1 as always, complement$1 as complement, F$1 as F, identity$1 as identity, not$1 as not, T$1 as T, trim$1 as trim, add$1 as add, addIndex$1 as addIndex, adjust$1 as adjust, all$1 as all, allPass$1 as allPass, anyPass$1 as anyPass, any$1 as any, append$1 as append, both$1 as both, compose$1 as compose, concat$1 as concat, contains$1 as contains, curry$1 as curry, dec$1 as dec, defaultTo$1 as defaultTo, divide$1 as divide, drop$1 as drop, dropLast$1 as dropLast, either$1 as either, endsWith$1 as endsWith, inc$1 as inc, equals$1 as equals, filter$1 as filter, find$1 as find, findIndex$1 as findIndex, flatten$1 as flatten, flip$1 as flip, forEach$1 as forEach, has$1 as has, head$1 as head, ifElse$1 as ifElse, is$1 as is, isNil$1 as isNil, includes$1 as includes, indexOf$1 as indexOf, init$1 as init, join$1 as join, lastIndexOf$1 as lastIndexOf, last$1 as last, length$1 as length, map$1 as map, match$1 as match, merge$1 as merge, modulo$1 as modulo, multiply$1 as multiply, none$1 as none, omit$1 as omit, partialCurry$1 as partialCurry, path$1 as path, pathOr$1 as pathOr, pick$1 as pick, pickAll$1 as pickAll, pipe$1 as pipe, pluck$1 as pluck, prepend$1 as prepend, prop$1 as prop, propEq$1 as propEq, range$1 as range, reduce$1 as reduce, reject$1 as reject, repeat$1 as repeat, replace$1 as replace, reverse$1 as reverse, sort$1 as sort, sortBy$1 as sortBy, split$1 as split, splitEvery$1 as splitEvery, startsWith$1 as startsWith, subtract$1 as subtract, tap$1 as tap, tail$1 as tail, take$1 as take, takeLast$1 as takeLast, test$1 as test, times$1 as times, toLower$1 as toLower, toUpper$1 as toUpper, toString$1 as toString, type$1 as type, uniq$1 as uniq, uniqWith$1 as uniqWith, update$1 as update, values$1 as values, without$1 as without, assocPath$1 as assocPath, compact, composeAsync, debounce, delay, debug, evolve$1 as evolve, greater, ifElseAsync, intersection, isPromiseLike, isValid, less, mapAsync, mapFastAsync, memoize, mergeAll, omitBy, once, pickBy, produce, random, rangeBy, renameProps, resolveMethod as resolve, resolveSecure, shuffle, switcher, tapAsync, throttle, tryCatch, when, where };\n//# sourceMappingURL=rambdax.esm.js.map\n","function add(x, y) {\n  if (y === undefined) {\n    return yHolder => add(x, yHolder);\n  }\n\n  return x + y;\n}\n\nfunction addIndex(functor) {\n  return function (fn, ...rest) {\n    let cnt = 0;\n    const newFn = (...args) => fn.apply(null, [...args, cnt++]);\n\n    return functor.apply(null, [newFn, ...rest]);\n  };\n}\n\nfunction adjust(fn, index, arr) {\n  if (index === undefined) {\n    return (indexHolder, arrHolder) => adjust(fn, indexHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => adjust(fn, index, arrHolder);\n  }\n\n  const clone = arr.concat();\n\n  return clone.map((val, key) => {\n    if (key === index) {\n      return fn(arr[index]);\n    }\n\n    return val;\n  });\n}\n\nfunction filterObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    if (fn(obj[prop], prop)) {\n      willReturn[prop] = obj[prop];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction filter(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => filter(fn, arrHolder);\n  }\n\n  if (arr.length === undefined) {\n    return filterObject(fn, arr);\n  }\n  let index = -1;\n  let resIndex = 0;\n  const len = arr.length;\n  const willReturn = [];\n\n  while (++index < len) {\n    const value = arr[index];\n\n    if (fn(value)) {\n      willReturn[resIndex++] = value;\n    }\n  }\n\n  return willReturn;\n}\n\nfunction all(condition, arr) {\n  if (arr === undefined) {\n    return arrHolder => all(condition, arrHolder);\n  }\n\n  return filter(condition, arr).length === arr.length;\n}\n\nfunction any(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => any(fn, arrHolder);\n  }\n  let counter = 0;\n\n  while (counter < arr.length) {\n    if (fn(arr[counter])) {\n      return true;\n    }\n    counter++;\n  }\n\n  return false;\n}\n\nfunction allPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => allPass(conditions, xHolder);\n  }\n\n  return !any(condition => !condition(x), conditions);\n}\n\nfunction anyPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => anyPass(conditions, xHolder);\n  }\n\n  return any(condition => condition(x))(conditions);\n}\n\nfunction append(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => append(x, arrHolder);\n  }\n  if (typeof arr === 'string') {\n    return `${arr}${x}`;\n  }\n  const clone = arr.concat();\n\n  clone.push(x);\n\n  return clone;\n}\n\nfunction both(x, y) {\n  if (y === undefined) {\n    return yHolder => both(x, yHolder);\n  }\n\n  return input => x(input) && y(input);\n}\n\n//Taken from https://github.com/getify/Functional-Light-JS/blob/master/ch4.md\nfunction compose(...fns) {\n  return result => {\n    const list = fns.slice();\n\n    while (list.length > 0) {\n      result = list.pop()(result);\n    }\n\n    return result;\n  };\n}\n\nfunction concat(x, y) {\n  if (y === undefined) {\n    return yHolder => concat(x, yHolder);\n  }\n\n  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];\n}\n\nfunction type(a) {\n  const typeOf = typeof a;\n\n  if (a === null) {\n    return 'Null';\n  } else if (a === undefined) {\n    return 'Undefined';\n  } else if (typeOf === 'boolean') {\n    return 'Boolean';\n  } else if (typeOf === 'number') {\n    return 'Number';\n  } else if (typeOf === 'string') {\n    return 'String';\n  } else if (Array.isArray(a)) {\n    return 'Array';\n  } else if (a instanceof RegExp) {\n    return 'RegExp';\n  }\n\n  const asStr = a.toString();\n\n  if (asStr.startsWith('async')) {\n    return 'Async';\n  } else if (asStr === '[object Promise]') {\n    return 'Promise';\n  } else if (asStr.includes('function') || asStr.includes('=>')) {\n    return 'Function';\n  }\n\n  return 'Object';\n}\n\nfunction equals(a, b) {\n  if (arguments.length === 1) {\n    return bHolder => equals(a, bHolder);\n  }\n\n  if (a === b) {\n    return true;\n  }\n  const aType = type(a);\n\n  if (aType !== type(b)) {\n    return false;\n  }\n\n  if (aType === 'Array') {\n    const aClone = Array.from(a);\n    const bClone = Array.from(b);\n\n    if (aClone.toString() !== bClone.toString()) {\n\n      return false;\n    }\n    let loopArrayFlag = true;\n\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag) {\n\n        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {\n          loopArrayFlag = false;\n        }\n      }\n    });\n\n    return loopArrayFlag;\n  }\n\n  if (aType === 'Object') {\n    const aKeys = Object.keys(a);\n\n    if (aKeys.length !== Object.keys(b).length) {\n\n      return false;\n    }\n\n    let loopObjectFlag = true;\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag) {\n        const aValue = a[aKeyInstance];\n        const bValue = b[aKeyInstance];\n\n        if (aValue !== bValue && !equals(aValue, bValue)) {\n          loopObjectFlag = false;\n        }\n      }\n    });\n\n    return loopObjectFlag;\n  }\n\n  return false;\n}\n\nfunction contains(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => contains(x, arrHolder);\n  }\n  let index = -1;\n  let flag = false;\n\n  while (++index < arr.length && !flag) {\n    if (equals(arr[index], x)) {\n      flag = true;\n    }\n  }\n\n  return flag;\n}\n\n//taken from the last comment of https://gist.github.com/mkuklis/5294248\n\nfunction curry(f, a = []) {\n  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);\n}\n\nvar dec = (x => x - 1);\n\nfunction defaultTo(defaultArgument, inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);\n  }\n\n  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true ? defaultArgument : inputArgument;\n}\n\nfunction divide(x, y) {\n  if (y === undefined) {\n    return yHolder => divide(x, yHolder);\n  }\n\n  return x / y;\n}\n\nfunction drop(dropNumber, x) {\n  if (x === undefined) {\n    return xHolder => drop(dropNumber, xHolder);\n  }\n\n  return x.slice(dropNumber);\n}\n\nfunction dropLast(dropNumber, x) {\n  if (x === undefined) {\n    return xHolder => dropLast(dropNumber, xHolder);\n  }\n\n  return x.slice(0, -dropNumber);\n}\n\nfunction either(x, y) {\n  if (y === undefined) {\n    return yHolder => either(x, yHolder);\n  }\n\n  return input => x(input) || y(input);\n}\n\nfunction endsWith(x, y) {\n  if (y === undefined) {\n    return yHolder => endsWith(x, yHolder);\n  }\n\n  return y.endsWith(x);\n}\n\nvar inc = (x => x + 1);\n\nfunction find(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => find(fn, arrHolder);\n  }\n\n  return arr.find(fn);\n}\n\nfunction findIndex(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => findIndex(fn, arrHolder);\n  }\n  const len = arr.length;\n  let index = -1;\n\n  while (++index < len) {\n    if (fn(arr[index])) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction flatten(arr, willReturn) {\n  willReturn = willReturn === undefined ? [] : willReturn;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      flatten(arr[i], willReturn);\n    } else {\n      willReturn.push(arr[i]);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction flipExport(fn) {\n  return (...input) => {\n    if (input.length === 1) {\n      return holder => fn(holder, input[0]);\n    } else if (input.length === 2) {\n      return fn(input[1], input[0]);\n    }\n\n    return undefined;\n  };\n}\n\nfunction flip(fn, ...input) {\n  return flipExport(fn);\n}\n\nfunction tap(fn, x) {\n  if (x === undefined) {\n    return xHolder => tap(fn, xHolder);\n  }\n\n  fn(x);\n\n  return x;\n}\n\nfunction mapObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    willReturn[prop] = fn(obj[prop], prop);\n  }\n\n  return willReturn;\n}\n\nfunction map(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => map(fn, arrHolder);\n  }\n  if (arr.length === undefined) {\n    return mapObject(fn, arr);\n  }\n  let index = -1;\n  const len = arr.length;\n  const willReturn = Array(len);\n\n  while (++index < len) {\n    willReturn[index] = fn(arr[index]);\n  }\n\n  return willReturn;\n}\n\nfunction forEach(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => forEach(fn, arrHolder);\n  }\n\n  return map(tap(fn), arr);\n}\n\nfunction has(prop, obj) {\n  if (obj === undefined) {\n    return objHolder => has(prop, objHolder);\n  }\n\n  return obj[prop] !== undefined;\n}\n\nfunction head(a) {\n  if (typeof a === 'string') {\n    return a[0] || '';\n  }\n\n  return a[0];\n}\n\nfunction ifElse(condition, ifFn, elseFn) {\n  if (ifFn === undefined) {\n    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);\n  } else if (elseFn === undefined) {\n    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);\n  }\n\n  return input => {\n    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (conditionResult === true) {\n      return ifFn(input);\n    }\n\n    return elseFn(input);\n  };\n}\n\nfunction is(xPrototype, x) {\n  if (x === undefined) {\n    return xHolder => is(xPrototype, xHolder);\n  }\n\n  return x instanceof xPrototype || x.constructor === xPrototype;\n}\n\nfunction isNil(x) {\n  return x === undefined || x === null;\n}\n\nfunction includes(x, y) {\n  if (y === undefined) {\n    return yHolder => includes(x, yHolder);\n  }\n\n  return y.includes(x);\n}\n\nfunction indexOf(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => indexOf(x, arrHolder);\n  }\n  let index = -1;\n  const length = arr.length;\n\n  while (++index < length) {\n    if (arr[index] === x) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction baseSlice(array, start, end) {\n  let index = -1;\n  let length = array.length;\n\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n\n  const result = Array(length);\n\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n\n  return result;\n}\n\nfunction init(a) {\n  if (typeof a === 'string') {\n    return a.slice(0, -1);\n  }\n\n  return a.length ? baseSlice(a, 0, -1) : [];\n}\n\nfunction join(glue, arr) {\n  if (arr === undefined) {\n    return arrHolder => join(glue, arrHolder);\n  }\n\n  return arr.join(glue);\n}\n\nfunction lastIndexOf(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => lastIndexOf(x, arrHolder);\n  }\n  let willReturn = -1;\n\n  arr.map((value, key) => {\n    if (equals(value, x)) {\n      willReturn = key;\n    }\n  });\n\n  return willReturn;\n}\n\nfunction last(a) {\n  if (typeof a === 'string') {\n    return a[a.length - 1] || '';\n  }\n\n  return a[a.length - 1];\n}\n\nfunction length(x) {\n  return x.length;\n}\n\nfunction match(regex, x) {\n  if (x === undefined) {\n    return xHolder => match(regex, xHolder);\n  }\n  const willReturn = x.match(regex);\n\n  return willReturn === null ? [] : willReturn;\n}\n\nfunction merge(obj, newProps) {\n  if (newProps === undefined) {\n    return newPropsHolder => merge(obj, newPropsHolder);\n  }\n\n  return Object.assign({}, obj, newProps);\n}\n\nfunction modulo(x, y) {\n  if (y === undefined) {\n    return yHolder => modulo(x, yHolder);\n  }\n\n  return x % y;\n}\n\nfunction multiply(x, y) {\n  if (y === undefined) {\n    return yHolder => multiply(x, yHolder);\n  }\n\n  return x * y;\n}\n\nfunction none(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => none(fn, arr);\n  }\n\n  return arr.filter(fn).length === 0;\n}\n\nfunction omit(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => omit(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n\n  const keysValue = typeof keys === 'string' ? keys = keys.split(',') : keys;\n\n  const willReturn = {};\n\n  for (const key in obj) {\n    if (!keysValue.includes(key)) {\n      willReturn[key] = obj[key];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction partialCurry(fn, inputArguments = {}) {\n  return inputArgumentsHolder => {\n    if (type(fn) === 'Async' || type(fn) === 'Promise') {\n      return new Promise((resolve, reject) => {\n        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);\n      });\n    }\n\n    return fn(merge(inputArgumentsHolder, inputArguments));\n  };\n}\n\nfunction path(pathArr, obj) {\n  if (arguments.length === 1) {\n    return objHolder => path(pathArr, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  let willReturn = obj;\n  let counter = 0;\n\n  const pathArrValue = typeof pathArr === 'string' ? pathArr = pathArr.split('.') : pathArr;\n\n  while (counter < pathArrValue.length) {\n    if (willReturn === null || willReturn === undefined) {\n      return undefined;\n    }\n    willReturn = willReturn[pathArrValue[counter]];\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pathOr(defaultValue, inputPath, inputObject) {\n  return defaultTo(defaultValue, path(inputPath, inputObject));\n}\n\nvar pathOr$1 = curry(pathOr);\n\nfunction pick(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pick(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pickAll(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pickAll(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    } else {\n      willReturn[keysValue[counter]] = undefined;\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pipe(...fns) {\n  return compose(...fns.reverse());\n}\n\nfunction pluck(keyToPluck, arr) {\n  if (arr === undefined) {\n    return arrHolder => pluck(keyToPluck, arrHolder);\n  }\n  const willReturn = [];\n\n  map(val => {\n    if (!(val[keyToPluck] === undefined)) {\n      willReturn.push(val[keyToPluck]);\n    }\n  }, arr);\n\n  return willReturn;\n}\n\nfunction prepend(x, arr) {\n  if (arr === undefined) {\n    return arrHolder => prepend(x, arrHolder);\n  }\n  if (typeof arr === 'string') {\n    return `${x}${arr}`;\n  }\n  const clone = arr.concat();\n\n  clone.unshift(x);\n\n  return clone;\n}\n\nfunction prop(key, obj) {\n  if (obj === undefined) {\n    return objHolder => prop(key, objHolder);\n  }\n\n  return obj[key];\n}\n\nfunction propEq(key, x, obj) {\n  if (x === undefined) {\n    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);\n  } else if (obj === undefined) {\n    return objHolder => propEq(key, x, objHolder);\n  }\n\n  return obj[key] === x;\n}\n\nfunction range(start, end) {\n  if (end === undefined) {\n    return endHolder => range(start, endHolder);\n  }\n  const willReturn = [];\n\n  for (let i = start; i < end; i++) {\n    willReturn.push(i);\n  }\n\n  return willReturn;\n}\n\nfunction reduce(fn, initialValue, arr) {\n  if (initialValue === undefined) {\n    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => reduce(fn, initialValue, arrHolder);\n  }\n\n  return arr.reduce(fn, initialValue);\n}\n\nfunction reject(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => reject(fn, arrHolder);\n  }\n\n  return filter(x => !fn(x), arr);\n}\n\nfunction repeat(x, num) {\n  if (num === undefined) {\n    return numHolder => repeat(x, numHolder);\n  }\n  const willReturn = Array(num);\n\n  return willReturn.fill(x);\n}\n\nfunction replace(regex, replacer, str) {\n  if (replacer === undefined) {\n    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);\n  } else if (str === undefined) {\n    return strHolder => replace(regex, replacer, strHolder);\n  }\n\n  return str.replace(regex, replacer);\n}\n\nfunction reverse(arr) {\n  const clone = arr.concat();\n\n  return clone.reverse();\n}\n\nfunction sort(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => sort(fn, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.sort(fn);\n}\n\nfunction sortBy(fn, arr) {\n  if (arr === undefined) {\n    return arrHolder => sortBy(fn, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.sort((a, b) => {\n    const fnA = fn(a);\n    const fnB = fn(b);\n\n    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;\n  });\n}\n\nfunction split(glue, str) {\n  if (str === undefined) {\n    return strHolder => split(glue, strHolder);\n  }\n\n  return str.split(glue);\n}\n\nfunction splitEvery(num, x) {\n  if (x === undefined) {\n    return xHolder => splitEvery(num, xHolder);\n  }\n\n  const numValue = num > 1 ? num : 1;\n\n  const willReturn = [];\n  let counter = 0;\n\n  while (counter < x.length) {\n    willReturn.push(x.slice(counter, counter += numValue));\n  }\n\n  return willReturn;\n}\n\nfunction startsWith(x, y) {\n  if (y === undefined) {\n    return yHolder => startsWith(x, yHolder);\n  }\n\n  return y.startsWith(x);\n}\n\nfunction subtract(x, y) {\n  if (y === undefined) {\n    return yHolder => subtract(x, yHolder);\n  }\n\n  return x - y;\n}\n\nfunction tail(arr) {\n  return drop(1, arr);\n}\n\nfunction take(num, x) {\n  if (x === undefined) {\n    return xHolder => take(num, xHolder);\n  }\n  if (typeof x === 'string') {\n    return x.slice(0, num);\n  }\n\n  return baseSlice(x, 0, num);\n}\n\nfunction takeLast(num, x) {\n  if (x === undefined) {\n    return xHolder => takeLast(num, xHolder);\n  }\n  const len = x.length;\n\n  let numValue = num > len ? len : num;\n\n  if (typeof x === 'string') {\n    return x.slice(len - numValue);\n  }\n  numValue = len - numValue;\n\n  return baseSlice(x, numValue, len);\n}\n\nfunction test(regex, str) {\n  if (str === undefined) {\n    return strHolder => test(regex, strHolder);\n  }\n\n  return str.search(regex) !== -1;\n}\n\nfunction times(fn, num) {\n  if (num === undefined) {\n    return numHolder => times(fn, numHolder);\n  }\n\n  return map(fn, range(0, num));\n}\n\nfunction toLower(x) {\n  return x.toLowerCase();\n}\n\nfunction toUpper(x) {\n  return x.toUpperCase();\n}\n\nfunction toString(x) {\n  return x.toString();\n}\n\nfunction uniq(arr) {\n  let index = -1;\n  const willReturn = [];\n\n  while (++index < arr.length) {\n    const value = arr[index];\n\n    if (!contains(value, willReturn)) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction uniqWith(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => uniqWith(fn, arrHolder);\n  }\n\n  let index = -1;\n  const willReturn = [];\n\n  while (++index < arr.length) {\n    const value = arr[index];\n    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);\n\n    if (!flag) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction update(index, newValue, arr) {\n  if (newValue === undefined) {\n    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => update(index, newValue, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.fill(newValue, index, index + 1);\n}\n\nfunction values(obj) {\n  const willReturn = [];\n\n  for (const key in obj) {\n    willReturn.push(obj[key]);\n  }\n\n  return willReturn;\n}\n\nfunction without(itemsToOmit, collection) {\n  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);\n}\n\nconst always = x => () => x;\nconst complement = fn => input => !fn(input);\nconst F = () => false;\nconst identity = x => x;\nconst not = x => !x;\nconst T = () => true;\nconst trim = x => x.trim();\n\nexport { always, complement, F, identity, not, T, trim, add, addIndex, adjust, all, allPass, anyPass, any, append, both, compose, concat, contains, curry, dec, defaultTo, divide, drop, dropLast, either, endsWith, inc, equals, filter, find, findIndex, flatten, flip, forEach, has, head, ifElse, is, isNil, includes, indexOf, init, join, lastIndexOf, last, length, map, match, merge, modulo, multiply, none, omit, partialCurry, path, pathOr$1 as pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, range, reduce, reject, repeat, replace, reverse, sort, sortBy, split, splitEvery, startsWith, subtract, tap, tail, take, takeLast, test, times, toLower, toUpper, toString, type, uniq, uniqWith, update, values, without };\n//# sourceMappingURL=rambda.esm.js.map\n","import {range, compose, filter} from 'rambdax'\n\nfunction isOdd(x){\n  return x % 2 === 0\n}\n\nfunction fn(x) {\n  return compose(\n    filter(isOdd),\n    range(2)\n  )(x)\n}\n\nconsole.log(fn(10))\n"],"names":["range$1","range","start","end","undefined","endHolder","willReturn","i","push","isOdd","x","console","log","fns","result","list","slice","length","pop","compose","filter","fn","arr","arrHolder","obj","prop","filterObject","index","resIndex","len","value"],"mappings":"AAguBA,MAgDMA,EC9nBN,SAimBSC,EAAMC,EAAOC,GACpB,QAAYC,IAARD,EACF,OAAOE,GAAaJ,EAAMC,EAAOG,GAEnC,MAAMC,KAEN,IAAK,IAAIC,EAAIL,EAAOK,EAAIJ,EAAKI,IAC3BD,EAAWE,KAAKD,GAGlB,OAAOD,GC3vBT,SAASG,EAAMC,GACb,OAAOA,EAAI,GAAM,EAGnB,IAAYA,EAOZC,QAAQC,KAPIF,EAOG,GD0Df,YA+DoBG,GAClB,OAAOC,IACL,MAAMC,EAAOF,EAAIG,QAEjB,KAAOD,EAAKE,OAAS,GACnBH,EAASC,EAAKG,KAALH,CAAWD,GAGtB,OAAOA,GCvIFK,CDwCT,SAASC,EAAOC,EAAIC,GAClB,QAAYlB,IAARkB,EACF,OAAOC,GAAaH,EAAOC,EAAIE,GAGjC,QAAmBnB,IAAfkB,EAAIL,OACN,OAlBJ,SAAsBI,EAAIG,GACxB,MAAMlB,KAEN,IAAK,MAAMmB,KAAQD,EACbH,EAAGG,EAAIC,GAAOA,KAChBnB,EAAWmB,GAAQD,EAAIC,IAI3B,OAAOnB,EASEoB,CAAaL,EAAIC,GAE1B,IAAIK,GAAS,EACTC,EAAW,EACf,MAAMC,EAAMP,EAAIL,OACVX,KAEN,OAASqB,EAAQE,GAAK,CACpB,MAAMC,EAAQR,EAAIK,GAEdN,EAAGS,KACLxB,EAAWsB,KAAcE,GAI7B,OAAOxB,EC5DLc,CAAOX,GACPR,EAAM,GAFDkB,CAGLT"}