{"version":3,"file":"tree-shaking-example.umd.js","sources":["../node_modules/rambdax/dist/rambdax.esm.js","../node_modules/rambda/dist/rambda.esm.js","../src/rambdax.js"],"sourcesContent":["import { curry, filter, type, equals, replace, toLower, contains, test, any, all, compose, map, sort, take, merge, range, length, last, split, omit, add, addIndex, adjust, allPass, anyPass, always, append, both, complement, concat, dec, defaultTo, dissoc, divide, drop, dropLast, either, endsWith, inc, F, find, findIndex, flatten, flip, forEach, has, head, identity, ifElse, is, isNil, includes, indexBy, indexOf, init, join, lastIndexOf, match, modulo, multiply, none, not, partialCurry, path, pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, reduce, reject, repeat, reverse, sortBy, splitEvery, startsWith, subtract, T, tap, tail, takeLast, times, toUpper, toString, trim, uniq, uniqWith, update, values, without } from 'rambda';\n\nfunction assocPath(path$$1, x, obj) {\n  const pathValue = typeof path$$1 === 'string' ? path$$1.split('.') : path$$1;\n\n  const lastProp = pathValue[pathValue.length - 1];\n\n  let newProps = { [lastProp]: x };\n\n  let counter = pathValue.length - 2;\n\n  while (counter > -1) {\n    const prop$$1 = pathValue[counter];\n    newProps = { [prop$$1]: newProps };\n\n    counter--;\n  }\n\n  return Object.assign({}, obj, newProps);\n}\n\nvar assocPath$1 = curry(assocPath);\n\nconst types = ['Null', 'Undefined', 'RegExp'];\n\nfunction compact(arr) {\n  return filter(a => {\n    const currentType = type(a);\n    if (types.includes(currentType)) {\n      return false;\n    }\n    if (currentType === 'Object') {\n      return !equals(a, {});\n    }\n\n    return a.length !== 0;\n  }, arr);\n}\n\nfunction composeAsync(...inputArguments) {\n  try {\n    return async function (startArgument) {\n      let argumentsToPass = startArgument;\n\n      while (inputArguments.length !== 0) {\n        const fn = inputArguments.pop();\n        if (type(fn) === 'Async' || type(fn) === 'Promise') {\n          argumentsToPass = await fn(argumentsToPass);\n        } else {\n          argumentsToPass = fn(argumentsToPass);\n        }\n      }\n\n      return argumentsToPass;\n    };\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction debounce(func, ms, immediate = false) {\n  let timeout;\n\n  return function (...input) {\n    const later = function () {\n      timeout = null;\n      if (!immediate) {\n        func.apply(null, input);\n      }\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, ms);\n    if (callNow) {\n      func.apply(null, input);\n    }\n  };\n}\n\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('RAMBDAX_DELAY');\n    }, ms);\n  });\n}\n\nfunction debug(...input) {\n  console.log(...input);\n  process.exit();\n}\n\nfunction evolve(rules, input) {\n  const clone = Object.assign({}, input);\n  const propRules = filter(x => clone[x] !== undefined)(Object.keys(rules));\n\n  if (propRules.length === 0) {\n    return input;\n  }\n\n  propRules.map(prop$$1 => {\n    const fn = rules[prop$$1];\n    if (type(fn) === 'Function') {\n      clone[prop$$1] = fn(clone[prop$$1]);\n    } else if (type(fn) === 'Object') {\n      clone[prop$$1] = evolve(fn, clone[prop$$1]);\n    }\n  });\n\n  return clone;\n}\n\nvar evolve$1 = curry(evolve);\n\nfunction greater(x, y) {\n  if (y === undefined) {\n    return yHolder => greater(x, yHolder);\n  }\n\n  return y > x;\n}\n\nfunction createThenable(x) {\n  return async function (input) {\n    return x(input);\n  };\n}\n\nfunction ifElseAsync(condition, ifFn, elseFn) {\n  if (ifFn === undefined) {\n    return (ifFnHolder, elseFnHolder) => ifElseAsync(condition, ifFnHolder, elseFnHolder);\n  } else if (elseFn === undefined) {\n    return elseFnHolder => ifElseAsync(condition, ifFn, elseFnHolder);\n  }\n\n  return input => new Promise((resolve, reject$$1) => {\n    const conditionPromise = createThenable(condition);\n    const ifFnPromise = createThenable(ifFn);\n    const elseFnPromise = createThenable(elseFn);\n\n    conditionPromise(input).then(conditionResult => {\n      const promised = conditionResult === true ? ifFnPromise : elseFnPromise;\n\n      promised(input).then(resolve).catch(reject$$1);\n    }).catch(reject$$1);\n  });\n}\n\nfunction inject(injection, marker, content) {\n\n  return replace(marker, `${marker}${injection}`, content);\n}\n\nfunction isPromiseLike(x) {\n  return ['Async', 'Promise'].includes(type(x));\n}\n\nfunction isValid({ input, schema }) {\n  if (type(input) === 'Object' && type(schema) === 'Object') {\n\n    let flag = true;\n    const boom = boomFlag => {\n      if (!boomFlag) {\n        flag = false;\n      }\n    };\n\n    for (const requirement in schema) {\n\n      if (flag) {\n        const rule = schema[requirement];\n        const ruleType = type(rule);\n        const inputProp = input[requirement];\n        const inputPropType = type(input[requirement]);\n\n        if (ruleType === 'Object') {\n          /**\n           * This rule is standalone schema - schema = {a: {b: 'string'}}\n           */\n          const isValidResult = isValid({\n            input: inputProp,\n            schema: rule\n          });\n          boom(isValidResult);\n        } else if (ruleType === 'String') {\n          /**\n           * rule is concrete rule such as 'number' so two types are compared\n           */\n          boom(toLower(inputPropType) === rule);\n        } else if (typeof rule === 'function') {\n          /**\n           * rule is function so we pass to it the input\n           */\n          boom(rule(inputProp));\n        } else if (ruleType === 'Array' && inputPropType === 'String') {\n          /**\n           * enum case | rule is like a: ['foo', 'bar']\n           */\n          boom(contains(inputProp, rule));\n        } else if (ruleType === 'Array' && rule.length === 1 && inputPropType === 'Array') {\n          /**\n           * 1. array of type | rule is like a: ['number']\n           * 2. rule is like a: [{from: 'string'}]\n           */\n          const currentRule = rule[0];\n          const currentRuleType = type(rule[0]);\n          // Check if rule is invalid\n          boom(currentRuleType === 'String' || currentRuleType === 'Object');\n\n          if (currentRuleType === 'String') {\n\n            /**\n             * 1. array of type\n             */\n            const isInvalidResult = any(inputPropInstance => type(inputPropInstance).toLowerCase() !== currentRule, inputProp);\n            boom(!isInvalidResult);\n          }\n\n          if (currentRuleType === 'Object') {\n\n            /**\n             * 2. rule is like a: [{from: 'string'}]\n             */\n            const isValidResult = all(inputPropInstance => isValid({ input: inputPropInstance, schema: currentRule }), inputProp);\n            boom(isValidResult);\n          }\n        } else if (ruleType === 'RegExp' && inputPropType === 'String') {\n\n          boom(test(rule, inputProp));\n        } else {\n\n          boom(false);\n        }\n      }\n    }\n\n    return flag;\n  }\n\n  return false;\n}\n\nfunction less(x, y) {\n  if (y === undefined) {\n    return yHolder => less(x, yHolder);\n  }\n\n  return y < x;\n}\n\nasync function mapAsyncFn(fn, arr) {\n  try {\n    if (Array.isArray(arr)) {\n      const willReturn = [];\n      for (const a of arr) {\n        willReturn.push((await fn(a)));\n      }\n\n      return willReturn;\n    }\n\n    const willReturn = {};\n    for (const prop$$1 in arr) {\n      willReturn[prop$$1] = await fn(arr[prop$$1], prop$$1);\n    }\n\n    return willReturn;\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction mapAsync(fn, arr) {\n  if (arr === undefined) {\n    return async holder => await mapAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    mapAsyncFn(fn, arr).then(resolve).catch(reject$$1);\n  });\n}\n\nasync function mapFastAsyncFn(fn, arr) {\n  try {\n    const promised = arr.map(a => fn(a));\n\n    return await Promise.all(promised);\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction mapFastAsync(fn, arr) {\n  if (arr === undefined) {\n    return async holder => await mapFastAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    mapFastAsyncFn(fn, arr).then(resolve).catch(reject$$1);\n  });\n}\n\nconst cache = {};\n\nconst normalizeObject = obj => {\n  const sortFn = (a, b) => a > b;\n  const willReturn = {};\n  compose(map(prop$$1 => willReturn[prop$$1] = obj[prop$$1]), sort(sortFn))(Object.keys(obj));\n\n  return willReturn;\n};\n\nconst stringify = a => {\n  if (type(a) === 'String') {\n    return a;\n  } else if (['Function', 'Async'].includes(type(a))) {\n    const compacted = replace(/\\s{1,}/g, ' ', a.toString());\n\n    return replace(/\\s/g, '_', take(15, compacted));\n  } else if (type(a) === 'Object') {\n    a = normalizeObject(a);\n  }\n\n  return JSON.stringify(a);\n};\n\nconst generateProp = (fn, ...inputArguments) => {\n  let propString = '';\n  inputArguments.map(inputArgument => {\n    propString += `${stringify(inputArgument)}_`;\n  });\n\n  return `${propString}${stringify(fn)}`;\n};\n\nfunction memoize(fn, ...inputArguments) {\n  if (arguments.length === 1) {\n    return (...inputArgumentsHolder) => memoize(fn, ...inputArgumentsHolder);\n  }\n  const prop$$1 = generateProp(fn, ...inputArguments);\n  if (prop$$1 in cache) {\n    return cache[prop$$1];\n  }\n  if (type(fn) === 'Async') {\n    return new Promise(resolve => {\n      fn(...inputArguments).then(result => {\n        cache[prop$$1] = result;\n        resolve(result);\n      });\n    });\n  }\n  const result = fn(...inputArguments);\n  cache[prop$$1] = result;\n\n  return result;\n}\n\nfunction mergeAll(arr) {\n  let willReturn = {};\n  map(val => {\n    willReturn = merge(willReturn, val);\n  }, arr);\n\n  return willReturn;\n}\n\nfunction omitBy(fn, obj) {\n  if (arguments.length === 1) {\n    return holder => omitBy(fn, holder);\n  }\n\n  const willReturn = {};\n  for (const prop$$1 in obj) {\n    if (!fn(prop$$1, obj[prop$$1])) {\n      willReturn[prop$$1] = obj[prop$$1];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction onceFn(fn, context) {\n  let result;\n\n  return function () {\n    if (fn) {\n      result = fn.apply(context || this, arguments);\n      fn = null;\n    }\n\n    return result;\n  };\n}\n\nfunction once(fn, context) {\n  if (arguments.length === 1) {\n    const wrap = onceFn(fn, context);\n\n    return curry(wrap);\n  }\n\n  return onceFn(fn, context);\n}\n\nfunction pickBy(fn, obj) {\n  if (arguments.length === 1) {\n    return holder => pickBy(fn, holder);\n  }\n\n  const willReturn = {};\n  for (const prop$$1 in obj) {\n    if (fn(prop$$1, obj[prop$$1])) {\n      willReturn[prop$$1] = obj[prop$$1];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction helper({ condition, inputArgument, prop: prop$$1 }) {\n  return new Promise((resolve, reject$$1) => {\n    if (!(type(condition) === 'Async')) {\n      return resolve({\n        type: prop$$1,\n        payload: condition(inputArgument)\n      });\n    }\n\n    condition(inputArgument).then(result => {\n      resolve({\n        type: prop$$1,\n        payload: result\n      });\n    }).catch(err => reject$$1(err));\n  });\n}\n\nfunction produce(conditions, inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => produce(conditions, inputArgumentHolder);\n  }\n  let asyncConditionsFlag = false;\n  for (const prop$$1 in conditions) {\n    if (asyncConditionsFlag === false && type(conditions[prop$$1]) === 'Async') {\n      asyncConditionsFlag = true;\n    }\n  }\n\n  if (asyncConditionsFlag === false) {\n    const willReturn = {};\n    for (const prop$$1 in conditions) {\n      willReturn[prop$$1] = conditions[prop$$1](inputArgument);\n    }\n\n    return willReturn;\n  }\n  const promised = [];\n  for (const prop$$1 in conditions) {\n    const condition = conditions[prop$$1];\n    promised.push(helper({\n      inputArgument,\n      condition,\n      prop: prop$$1\n    }));\n  }\n\n  return new Promise((resolve, reject$$1) => {\n    Promise.all(promised).then(results => {\n      const willReturn = {};\n\n      map(result => willReturn[result.type] = result.payload, results);\n\n      resolve(willReturn);\n    }).catch(err => reject$$1(err));\n  });\n}\n\nfunction random(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction rangeBy(startNum, endNum, distance) {\n  if (endNum === undefined) {\n    return (endNumHolder, distanceHolder) => rangeBy(startNum, endNumHolder, distanceHolder);\n  } else if (distance === undefined) {\n    return distanceHolder => rangeBy(startNum, endNum, distanceHolder);\n  }\n\n  const isInteger = !distance.toString().includes('.');\n  if (startNum > endNum) {\n    const startNumHolder = startNum;\n    startNum = endNum;\n    endNum = startNumHolder;\n  }\n  const willReturn = [startNum];\n  let valueToPush = startNum;\n\n  if (isInteger) {\n    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));\n    for (const i of loopIndexes) {\n      valueToPush += distance;\n      willReturn.push(valueToPush);\n    }\n  } else {\n    const decimalLength = compose(length, last, split('.'))(distance.toString());\n    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));\n    for (const i of loopIndexes) {\n      valueToPush += distance;\n      willReturn.push(Number(valueToPush.toFixed(decimalLength)));\n    }\n  }\n\n  return willReturn;\n}\n\nfunction renameProps(conditions, inputObject) {\n  if (inputObject === undefined) {\n    return inputObjectHolder => renameProps(conditions, inputObjectHolder);\n  }\n  const renamed = {};\n  Object.keys(conditions).map(renameConditionProp => {\n    if (Object.keys(inputObject).includes(renameConditionProp)) {\n      renamed[conditions[renameConditionProp]] = inputObject[renameConditionProp];\n    }\n  });\n\n  return merge(renamed, omit(Object.keys(conditions), inputObject));\n}\n\nfunction resolveMethod(promises) {\n  return new Promise((res, rej) => {\n    let counter = 0;\n    const props = {};\n    const promisedArr = [];\n    for (const prop$$1 in promises) {\n      props[counter] = prop$$1;\n      promisedArr.push(promises[prop$$1]);\n      counter++;\n    }\n    Promise.all(promisedArr).then(result => {\n      const willReturn = {};\n      result.map((val, key) => {\n        const prop$$1 = props[key];\n        willReturn[prop$$1] = val;\n      });\n\n      res(willReturn);\n    }).catch(rej);\n  });\n}\n\nconst resolveSecureWrapper = promise => new Promise(res => {\n  promise.then(result => {\n    res({\n      payload: result,\n      type: 'RESULT'\n    });\n  }).catch(err => {\n    res({\n      payload: err,\n      type: 'ERROR'\n    });\n  });\n});\n\nasync function resolveSecure(input) {\n  try {\n    const promised = map(a => resolveSecureWrapper(a), input);\n\n    return await Promise.all(promised);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nfunction shuffle(arrayRaw) {\n  const array = arrayRaw.concat();\n  let counter = array.length;\n  while (counter > 0) {\n    const index = Math.floor(Math.random() * counter);\n    counter--;\n    const temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n\n  return array;\n}\n\nconst NO_MATCH_FOUND = Symbol('NO_MATCH_FOUND');\n\nconst getMatchingKeyValuePair = (cases, testValue, defaultValue) => {\n  let iterationValue;\n\n  for (let index = 0; index < cases.length; index++) {\n    iterationValue = cases[index].test(testValue);\n\n    if (iterationValue !== NO_MATCH_FOUND) {\n      return iterationValue;\n    }\n  }\n\n  return defaultValue;\n};\n\nconst isEqual = (testValue, matchValue) => {\n  const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);\n\n  return willReturn;\n};\n\nconst is$1 = (testValue, matchResult = true) => ({\n  key: testValue,\n  test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND\n});\n\nclass Switchem {\n\n  constructor(defaultValue, cases, willMatch) {\n    if (defaultValue !== undefined && cases === undefined && willMatch === undefined) {\n      this.cases = [];\n      this.defaultValue = undefined;\n      this.willMatch = defaultValue;\n    } else {\n      this.cases = cases;\n      this.defaultValue = defaultValue;\n      this.willMatch = willMatch;\n    }\n\n    return this;\n  }\n\n  default(defaultValue) {\n    const holder = new Switchem(defaultValue, this.cases, this.willMatch);\n\n    return holder.match(this.willMatch);\n  }\n\n  is(testValue, matchResult) {\n    return new Switchem(this.defaultValue, [...this.cases, is$1(testValue, matchResult)], this.willMatch);\n  }\n\n  match(matchValue) {\n\n    return getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);\n  }\n\n}\n\nfunction switcher(input) {\n  return new Switchem(input);\n}\n\nfunction tapAsync(fn, input) {\n  if (arguments.length === 1) {\n    return inputHolder => tapAsync(fn, inputHolder);\n  }\n  if (isPromiseLike(fn) === true) {\n    return new Promise((resolve, reject$$1) => {\n      fn(input).then(() => {\n        resolve(input);\n      }).catch(reject$$1);\n    });\n  }\n  fn(input);\n\n  return input;\n}\n\nfunction throttle(fn, ms) {\n  let wait = false;\n\n  return function (...input) {\n    if (!wait) {\n      fn.apply(null, input);\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n      }, ms);\n    }\n  };\n}\n\nfunction when(condition, whenTrueFn) {\n  if (whenTrueFn === undefined) {\n    return whenTrueFnHolder => when(condition, whenTrueFnHolder);\n  }\n\n  return input => {\n    const flag = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (flag) {\n      return whenTrueFn(input);\n    }\n\n    return input;\n  };\n}\n\nfunction createThenable$1(x) {\n  return async function (input) {\n    return x(input);\n  };\n}\n\nfunction whenAsync(condition, whenTrueFn) {\n  if (whenTrueFn === undefined) {\n\n    return (condition, whenTrueFnHolder) => whenAsync(condition, whenTrueFnHolder);\n  }\n\n  return input => new Promise((resolve, reject$$1) => {\n\n    if (typeof condition === 'boolean') {\n\n      if (condition === false) {\n\n        return resolve(input);\n      }\n\n      whenTrueFn(input).then(resolve).catch(reject$$1);\n    } else {\n\n      const conditionPromise = createThenable$1(condition);\n\n      conditionPromise(input).then(conditionResult => {\n\n        if (conditionResult === false) {\n\n          return resolve(input);\n        }\n\n        whenTrueFn(input).then(resolve).catch(reject$$1);\n      }).catch(reject$$1);\n    }\n  });\n}\n\nfunction where(conditions, obj) {\n  if (obj === undefined) {\n    return objHolder => where(conditions, objHolder);\n  }\n  let flag = true;\n  for (const prop$$1 in conditions) {\n    const result = conditions[prop$$1](obj[prop$$1]);\n    if (flag && result === false) {\n      flag = false;\n    }\n  }\n\n  return flag;\n}\n\nconst DELAY = 'RAMBDAX_DELAY';\n\n// Follows code generated by `run rambda`\nconst add$1 = add;\nconst addIndex$1 = addIndex;\nconst adjust$1 = adjust;\nconst all$1 = all;\nconst allPass$1 = allPass;\nconst anyPass$1 = anyPass;\nconst always$1 = always;\nconst any$1 = any;\nconst append$1 = append;\nconst both$1 = both;\nconst complement$1 = complement;\nconst compose$1 = compose;\nconst concat$1 = concat;\nconst contains$1 = contains;\nconst curry$1 = curry;\nconst dec$1 = dec;\nconst defaultTo$1 = defaultTo;\nconst dissoc$1 = dissoc;\nconst divide$1 = divide;\nconst drop$1 = drop;\nconst dropLast$1 = dropLast;\nconst either$1 = either;\nconst endsWith$1 = endsWith;\nconst inc$1 = inc;\nconst equals$1 = equals;\nconst F$1 = F;\nconst filter$1 = filter;\nconst find$1 = find;\nconst findIndex$1 = findIndex;\nconst flatten$1 = flatten;\nconst flip$1 = flip;\nconst forEach$1 = forEach;\nconst has$1 = has;\nconst head$1 = head;\nconst identity$1 = identity;\nconst ifElse$1 = ifElse;\nconst is$2 = is;\nconst isNil$1 = isNil;\nconst includes$1 = includes;\nconst indexBy$1 = indexBy;\nconst indexOf$1 = indexOf;\nconst init$1 = init;\nconst join$1 = join;\nconst lastIndexOf$1 = lastIndexOf;\nconst last$1 = last;\nconst length$1 = length;\nconst map$1 = map;\nconst match$1 = match;\nconst merge$1 = merge;\nconst modulo$1 = modulo;\nconst multiply$1 = multiply;\nconst none$1 = none;\nconst not$1 = not;\nconst omit$1 = omit;\nconst partialCurry$1 = partialCurry;\nconst path$1 = path;\nconst pathOr$1 = pathOr;\nconst pick$1 = pick;\nconst pickAll$1 = pickAll;\nconst pipe$1 = pipe;\nconst pluck$1 = pluck;\nconst prepend$1 = prepend;\nconst prop$1 = prop;\nconst propEq$1 = propEq;\nconst range$1 = range;\nconst reduce$1 = reduce;\nconst reject$1 = reject;\nconst repeat$1 = repeat;\nconst replace$1 = replace;\nconst reverse$1 = reverse;\nconst sort$1 = sort;\nconst sortBy$1 = sortBy;\nconst split$1 = split;\nconst splitEvery$1 = splitEvery;\nconst startsWith$1 = startsWith;\nconst subtract$1 = subtract;\nconst T$1 = T;\nconst tap$1 = tap;\nconst tail$1 = tail;\nconst take$1 = take;\nconst takeLast$1 = takeLast;\nconst test$1 = test;\nconst times$1 = times;\nconst toLower$1 = toLower;\nconst toUpper$1 = toUpper;\nconst toString$1 = toString;\nconst trim$1 = trim;\nconst type$1 = type;\nconst uniq$1 = uniq;\nconst uniqWith$1 = uniqWith;\nconst update$1 = update;\nconst values$1 = values;\nconst without$1 = without;\n\nexport { DELAY, add$1 as add, addIndex$1 as addIndex, adjust$1 as adjust, all$1 as all, allPass$1 as allPass, anyPass$1 as anyPass, always$1 as always, any$1 as any, append$1 as append, both$1 as both, complement$1 as complement, compose$1 as compose, concat$1 as concat, contains$1 as contains, curry$1 as curry, dec$1 as dec, defaultTo$1 as defaultTo, dissoc$1 as dissoc, divide$1 as divide, drop$1 as drop, dropLast$1 as dropLast, either$1 as either, endsWith$1 as endsWith, inc$1 as inc, equals$1 as equals, F$1 as F, filter$1 as filter, find$1 as find, findIndex$1 as findIndex, flatten$1 as flatten, flip$1 as flip, forEach$1 as forEach, has$1 as has, head$1 as head, identity$1 as identity, ifElse$1 as ifElse, is$2 as is, isNil$1 as isNil, includes$1 as includes, indexBy$1 as indexBy, indexOf$1 as indexOf, init$1 as init, join$1 as join, lastIndexOf$1 as lastIndexOf, last$1 as last, length$1 as length, map$1 as map, match$1 as match, merge$1 as merge, modulo$1 as modulo, multiply$1 as multiply, none$1 as none, not$1 as not, omit$1 as omit, partialCurry$1 as partialCurry, path$1 as path, pathOr$1 as pathOr, pick$1 as pick, pickAll$1 as pickAll, pipe$1 as pipe, pluck$1 as pluck, prepend$1 as prepend, prop$1 as prop, propEq$1 as propEq, range$1 as range, reduce$1 as reduce, reject$1 as reject, repeat$1 as repeat, replace$1 as replace, reverse$1 as reverse, sort$1 as sort, sortBy$1 as sortBy, split$1 as split, splitEvery$1 as splitEvery, startsWith$1 as startsWith, subtract$1 as subtract, T$1 as T, tap$1 as tap, tail$1 as tail, take$1 as take, takeLast$1 as takeLast, test$1 as test, times$1 as times, toLower$1 as toLower, toUpper$1 as toUpper, toString$1 as toString, trim$1 as trim, type$1 as type, uniq$1 as uniq, uniqWith$1 as uniqWith, update$1 as update, values$1 as values, without$1 as without, assocPath$1 as assocPath, compact, composeAsync, debounce, delay, debug, evolve$1 as evolve, greater, ifElseAsync, inject, isPromiseLike, isValid, less, mapAsync, mapFastAsync, memoize, mergeAll, omitBy, once, pickBy, produce, random, rangeBy, renameProps, resolveMethod as resolve, resolveSecure, shuffle, switcher, tapAsync, throttle, when, whenAsync, where };\n","function n(r,t){return void 0===t?function(t){return n(r,t)}:r+t}function r(n){return function(r){for(var t=[],u=arguments.length-1;u-- >0;)t[u]=arguments[u+1];var i=0;return n.apply(null,[function(){for(var n=[],t=arguments.length;t--;)n[t]=arguments[t];return r.apply(null,n.concat([i++]))}].concat(t))}}function t(n,r,u){return void 0===r?function(r,u){return t(n,r,u)}:void 0===u?function(u){return t(n,r,u)}:u.concat().map(function(t,i){return i===r?n(u[r]):t})}function u(n,r){if(void 0===r)return function(r){return u(n,r)};if(void 0===r.length)return function(n,r){var t={};for(var u in r)n(r[u],u)&&(t[u]=r[u]);return t}(n,r);for(var t=-1,i=0,o=r.length,e=[];++t<o;){var f=r[t];n(f)&&(e[i++]=f)}return e}function i(n,r){return void 0===r?function(r){return i(n,r)}:u(n,r).length===r.length}function o(n,r){if(void 0===r)return function(r){return o(n,r)};for(var t=0;t<r.length;){if(n(r[t]))return!0;t++}return!1}function e(n,r){return 1===arguments.length?function(r){return e(n,r)}:!o(function(n){return!n(r)},n)}function f(n,r){return 1===arguments.length?function(r){return f(n,r)}:o(function(n){return n(r)})(n)}function c(n){return function(){return n}}function v(n,r){if(void 0===r)return function(r){return v(n,r)};if(\"string\"==typeof r)return\"\"+r+n;var t=r.concat();return t.push(n),t}function a(n,r){return void 0===r?function(r){return a(n,r)}:function(t){return n(t)&&r(t)}}function l(n){return function(r){return!n(r)}}function d(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];return function(){for(var r=[],t=arguments.length;t--;)r[t]=arguments[t];var u=n.slice();if(u.length>0){for(var i=u.pop().apply(void 0,r);u.length>0;)i=u.pop()(i);return i}}}function g(n,r){return void 0===r?function(r){return g(n,r)}:\"string\"==typeof n?\"\"+n+r:n.concat(r)}function h(n){var r=typeof n;if(null===n)return\"Null\";if(void 0===n)return\"Undefined\";if(\"boolean\"===r)return\"Boolean\";if(\"number\"===r)return\"Number\";if(\"string\"===r)return\"String\";if(Array.isArray(n))return\"Array\";if(n instanceof RegExp)return\"RegExp\";var t=n.toString();return t.startsWith(\"async\")?\"Async\":\"[object Promise]\"===t?\"Promise\":t.includes(\"function\")||t.includes(\"=>\")?\"Function\":\"Object\"}function s(n,r){if(1===arguments.length)return function(r){return s(n,r)};if(n===r)return!0;var t=h(n);if(t!==h(r))return!1;if(\"Array\"===t){var u=Array.from(n),i=Array.from(r);if(u.toString()!==i.toString())return!1;var o=!0;return u.forEach(function(n,r){o&&(n===i[r]||s(n,i[r])||(o=!1))}),o}if(\"Object\"===t){var e=Object.keys(n);if(e.length!==Object.keys(r).length)return!1;var f=!0;return e.forEach(function(t){if(f){var u=n[t],i=r[t];u===i||s(u,i)||(f=!1)}}),f}return!1}function p(n,r){if(void 0===r)return function(r){return p(n,r)};for(var t=-1,u=!1;++t<r.length&&!u;)s(r[t],n)&&(u=!0);return u}function y(n,r){return void 0===r&&(r=[]),function(){for(var t,u=[],i=arguments.length;i--;)u[i]=arguments[i];return(t=r.concat(u)).length>=n.length?n.apply(void 0,t):y(n,t)}}function m(n){return n-1}function A(n,r){return 1===arguments.length?function(r){return A(n,r)}:void 0===r||null===r||!0===Number.isNaN(r)?n:r}function b(n,r){if(1===arguments.length)return function(r){return b(n,r)};if(null!==r&&void 0!==r){var t=\"string\"==typeof n?n=n.split(\",\"):n,u={};for(var i in r)t.includes(i)||(u[i]=r[i]);return u}}function j(n,r){if(1===arguments.length)return function(r){return j(n,r)};if(null!==r&&void 0!==r){var t={};for(var u in r)u!==\"\"+n&&(t[u]=r[u]);return t}}function O(n,r){return void 0===r?function(r){return O(n,r)}:n/r}function N(n,r){return void 0===r?function(r){return N(n,r)}:r.slice(n)}function S(n,r){return void 0===r?function(r){return S(n,r)}:r.slice(0,-n)}function E(n,r){return void 0===r?function(r){return E(n,r)}:function(t){return n(t)||r(t)}}function P(n,r){return void 0===r?function(r){return P(n,r)}:r.endsWith(n)}function x(n){return n+1}function W(){return!1}function k(n,r){return void 0===r?function(r){return k(n,r)}:r.find(n)}function w(n,r){if(void 0===r)return function(r){return w(n,r)};for(var t=r.length,u=-1;++u<t;)if(n(r[u]))return u;return-1}function C(n,r){r=void 0===r?[]:r;for(var t=0;t<n.length;t++)Array.isArray(n[t])?C(n[t],r):r.push(n[t]);return r}function R(n){for(var r=[],t=arguments.length-1;t-- >0;)r[t]=arguments[t+1];return function(n){return function(){for(var r=[],t=arguments.length;t--;)r[t]=arguments[t];return 1===r.length?function(t){return n(t,r[0])}:2===r.length?n(r[1],r[0]):void 0}}(n)}function U(n,r){if(void 0===r)return function(r){return U(n,r)};if(void 0===r.length)return function(n,r){var t={};for(var u in r)t[u]=n(r[u],u);return t}(n,r);for(var t=-1,u=r.length,i=Array(u);++t<u;)i[t]=n(r[t]);return i}function B(n,r){return void 0===r?function(r){return B(n,r)}:(U(n,r),r)}function F(n,r){if(void 0===r)return function(r){return F(n,r)};for(var t={},u=0;u<r.length;u++){var i=r[u],o=n(i);t[o]||(t[o]=[]),t[o].push(i)}return t}function L(n,r){return void 0===r?function(r){return L(n,r)}:void 0!==r[n]}function q(n){return\"string\"==typeof n?n[0]||\"\":n[0]}function z(n){return n}function D(n,r,t){return void 0===r?function(r,t){return D(n,r,t)}:void 0===t?function(t){return D(n,r,t)}:function(u){return!0===(\"boolean\"==typeof n?n:n(u))?r(u):t(u)}}function G(n,r){return void 0===r?function(r){return G(n,r)}:r instanceof n||r.constructor===n}function H(n){return void 0===n||null===n}function I(n,r){return void 0===r?function(r){return I(n,r)}:r.includes(n)}function J(n,r){if(void 0===r)return function(r){return J(n,r)};for(var t={},u=0;u<r.length;u++){var i=r[u];t[n(i)]=i}return t}function K(n,r){if(void 0===r)return function(r){return K(n,r)};for(var t=-1,u=r.length;++t<u;)if(r[t]===n)return t;return-1}function M(n,r,t){var u=-1,i=n.length;(t=t>i?i:t)<0&&(t+=i),i=r>t?0:t-r>>>0,r>>>=0;for(var o=Array(i);++u<i;)o[u]=n[u+r];return o}function Q(n){return\"string\"==typeof n?n.slice(0,-1):n.length?M(n,0,-1):[]}function T(n,r){return void 0===r?function(r){return T(n,r)}:r.join(n)}function V(n,r){if(void 0===r)return function(r){return V(n,r)};var t=-1;return r.map(function(r,u){s(r,n)&&(t=u)}),t}function X(n){return\"string\"==typeof n?n[n.length-1]||\"\":n[n.length-1]}function Y(n){return n.length}function Z(n,r){if(void 0===r)return function(r){return Z(n,r)};var t=r.match(n);return null===t?[]:t}function $(n,r){return void 0===r?function(r){return $(n,r)}:Object.assign({},n,r)}function _(n,r){return void 0===r?function(r){return _(n,r)}:n%r}function nn(n,r){return void 0===r?function(r){return nn(n,r)}:n*r}function rn(n,r){return void 0===r?function(r){return rn(n,r)}:0===r.filter(n).length}function tn(n){return!n}function un(n,r){return void 0===r&&(r={}),function(t){return\"Async\"===h(n)||\"Promise\"===h(n)?new Promise(function(u,i){n($(t,r)).then(u).catch(i)}):n($(t,r))}}function on(n,r){if(1===arguments.length)return function(r){return on(n,r)};if(null!==r&&void 0!==r){for(var t=r,u=0,i=\"string\"==typeof n?n.split(\".\"):n;u<i.length;){if(null===t||void 0===t)return;t=t[i[u]],u++}return t}}var en=y(function(n,r,t){return A(n,on(r,t))});function fn(n,r){if(1===arguments.length)return function(r){return fn(n,r)};if(null!==r&&void 0!==r){for(var t=\"string\"==typeof n?n.split(\",\"):n,u={},i=0;i<t.length;)t[i]in r&&(u[t[i]]=r[t[i]]),i++;return u}}function cn(n,r){if(1===arguments.length)return function(r){return cn(n,r)};if(null!==r&&void 0!==r){for(var t=\"string\"==typeof n?n.split(\",\"):n,u={},i=0;i<t.length;)u[t[i]]=t[i]in r?r[t[i]]:void 0,i++;return u}}function vn(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];return d.apply(void 0,n.reverse())}function an(n,r){if(void 0===r)return function(r){return an(n,r)};var t=[];return U(function(r){void 0!==r[n]&&t.push(r[n])},r),t}function ln(n,r){if(void 0===r)return function(r){return ln(n,r)};if(\"string\"==typeof r)return\"\"+n+r;var t=r.concat();return t.unshift(n),t}function dn(n,r){return void 0===r?function(r){return dn(n,r)}:r[n]}function gn(n,r,t){return void 0===r?function(r,t){return gn(n,r,t)}:void 0===t?function(t){return gn(n,r,t)}:t[n]===r}function hn(n,r){if(void 0===r)return function(r){return hn(n,r)};for(var t=[],u=n;u<r;u++)t.push(u);return t}function sn(n,r,t){return void 0===r?function(r,t){return sn(n,r,t)}:void 0===t?function(t){return sn(n,r,t)}:t.reduce(n,r)}function pn(n,r){return void 0===r?function(r){return pn(n,r)}:u(function(r){return!n(r)},r)}function yn(n,r){return void 0===r?function(r){return yn(n,r)}:Array(r).fill(n)}function mn(n,r,t){return void 0===r?function(r,t){return mn(n,r,t)}:void 0===t?function(t){return mn(n,r,t)}:t.replace(n,r)}function An(n){return n.concat().reverse()}function bn(n,r){return void 0===r?function(r){return bn(n,r)}:r.concat().sort(n)}function jn(n,r){return void 0===r?function(r){return jn(n,r)}:r.concat().sort(function(r,t){var u=n(r),i=n(t);return u<i?-1:u>i?1:0})}function On(n,r){return void 0===r?function(r){return On(n,r)}:r.split(n)}function Nn(n,r){if(void 0===r)return function(r){return Nn(n,r)};for(var t=n>1?n:1,u=[],i=0;i<r.length;)u.push(r.slice(i,i+=t));return u}function Sn(n,r){return void 0===r?function(r){return Sn(n,r)}:r.startsWith(n)}function En(n,r){return void 0===r?function(r){return En(n,r)}:n-r}function Pn(){return!0}function xn(n,r){return void 0===r?function(r){return xn(n,r)}:(n(r),r)}function Wn(n){return N(1,n)}function kn(n,r){return void 0===r?function(r){return kn(n,r)}:\"string\"==typeof r?r.slice(0,n):M(r,0,n)}function wn(n,r){if(void 0===r)return function(r){return wn(n,r)};var t=r.length,u=n>t?t:n;return\"string\"==typeof r?r.slice(t-u):M(r,u=t-u,t)}function Cn(n,r){return void 0===r?function(r){return Cn(n,r)}:-1!==r.search(n)}function Rn(n,r){return void 0===r?function(r){return Rn(n,r)}:U(n,hn(0,r))}function Un(n){return n.toLowerCase()}function Bn(n){return n.toUpperCase()}function Fn(n){return n.toString()}function Ln(n){return n.trim()}function qn(n){for(var r=-1,t=[];++r<n.length;){var u=n[r];p(u,t)||t.push(u)}return t}function zn(n,r){if(1===arguments.length)return function(r){return zn(n,r)};for(var t=-1,u=[],i=function(){var i=r[t];o(function(r){return n(i,r)},u)||u.push(i)};++t<r.length;)i();return u}function Dn(n,r,t){return void 0===r?function(r,t){return Dn(n,r,t)}:void 0===t?function(t){return Dn(n,r,t)}:t.concat().fill(r,n,n+1)}function Gn(n){var r=[];for(var t in n)r.push(n[t]);return r}function Hn(n,r){return sn(function(r,t){return p(t,n)?r:r.concat(t)},[],r)}function In(n,t){return void 0===t?function(r){return In(n,r)}:r(sn)(function(n,r,u){return t[u]?n.concat([[r,t[u]]]):n},[],n)}export{n as add,r as addIndex,t as adjust,i as all,e as allPass,f as anyPass,c as always,o as any,v as append,a as both,l as complement,d as compose,g as concat,p as contains,y as curry,m as dec,A as defaultTo,j as dissoc,O as divide,N as drop,S as dropLast,E as either,P as endsWith,x as inc,s as equals,W as F,u as filter,k as find,w as findIndex,C as flatten,R as flip,B as forEach,F as groupBy,L as has,q as head,z as identity,D as ifElse,G as is,H as isNil,I as includes,J as indexBy,K as indexOf,Q as init,T as join,V as lastIndexOf,X as last,Y as length,U as map,Z as match,$ as merge,_ as modulo,nn as multiply,rn as none,tn as not,b as omit,un as partialCurry,on as path,en as pathOr,fn as pick,cn as pickAll,vn as pipe,an as pluck,ln as prepend,dn as prop,gn as propEq,hn as range,sn as reduce,pn as reject,yn as repeat,mn as replace,An as reverse,bn as sort,jn as sortBy,On as split,Nn as splitEvery,Sn as startsWith,En as subtract,Pn as T,xn as tap,Wn as tail,kn as take,wn as takeLast,Cn as test,Rn as times,Un as toLower,Bn as toUpper,Fn as toString,Ln as trim,h as type,qn as uniq,zn as uniqWith,Dn as update,Gn as values,Hn as without,In as zip};\n//# sourceMappingURL=rambda.esm.js.map\n","import {range, compose, filter} from 'rambdax'\n\nfunction isOdd(x){\n  return x % 2 === 0\n}\n\nfunction fn(x) {\n  return compose(\n    filter(isOdd),\n    range(2)\n  )(x)\n}\n\nconsole.log(fn(10))\n"],"names":["range$1","hn","n","r","t","u","push","isOdd","x","console","log","arguments","length","slice","i","pop","apply","compose","o","e","f","filter","range"],"mappings":"0IA+vBA,MAqDMA,ECpzB4oD,SAAksMC,EAAGC,EAAEC,GAAG,QAAG,IAASA,EAAE,OAAO,SAASA,GAAG,OAAOF,EAAGC,EAAEC,IAAI,IAAI,IAAIC,KAAKC,EAAEH,EAAEG,EAAEF,EAAEE,IAAID,EAAEE,KAAKD,GAAG,OAAOD,GCEv7P,SAASG,EAAMC,GACb,OAAOA,EAAI,GAAM,EAGnB,IAAYA,EAOZC,QAAQC,KAPIF,EAOG,GDb0rB,WAAouB,IAAI,IAAIN,KAAKC,EAAEQ,UAAUC,OAAOT,KAAKD,EAAEC,GAAGQ,UAAUR,GAAG,OAAO,WAAW,IAAI,IAAIA,KAAKC,EAAEO,UAAUC,OAAOR,KAAKD,EAAEC,GAAGO,UAAUP,GAAG,IAAIC,EAAEH,EAAEW,QAAQ,GAAGR,EAAEO,OAAO,EAAE,CAAC,IAAI,IAAIE,EAAET,EAAEU,MAAMC,WAAM,EAAOb,GAAGE,EAAEO,OAAO,GAAGE,EAAET,EAAEU,KAAFV,CAAQS,GAAG,OAAOA,ICOroDG,CDP0c,SAASZ,EAAEH,EAAEC,GAAG,QAAG,IAASA,EAAE,OAAO,SAASA,GAAG,OAAOE,EAAEH,EAAEC,IAAI,QAAG,IAASA,EAAES,OAAO,OAAO,SAASV,EAAEC,GAAG,IAAIC,KAAK,IAAI,IAAIC,KAAKF,EAAED,EAAEC,EAAEE,GAAGA,KAAKD,EAAEC,GAAGF,EAAEE,IAAI,OAAOD,EAApE,CAAuEF,EAAEC,GAAG,IAAI,IAAIC,GAAG,EAAEU,EAAE,EAAEI,EAAEf,EAAES,OAAOO,OAAOf,EAAEc,GAAG,CAAC,IAAIE,EAAEjB,EAAEC,GAAGF,EAAEkB,KAAKD,EAAEL,KAAKM,GAAG,OAAOD,ECQnsBE,CAAOd,GACPe,EAAM,GAFDL,CAGLT"}